---
title: 钉钉自动打卡探索
comments: false
toc: true
date: 2021-05-19 16:15:08
pathsuffix: dingding-auto-clock
updated:
tags:
categories:
---

# 方案一：利用通知保活自身App，在开启的后台服务中执行定时任务

定义执行任务的服务，在服务开启的时候显示通知栏的通知保活

<details>
<summary>点我展开</summary>

```kotlin
import android.app.*
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.IBinder
import android.util.Log
import cn.ljt.clock.open
import cn.ljt.clock.playAudio
import com.tencent.mmkv.MMKV
import java.text.SimpleDateFormat
import java.util.*
import kotlin.concurrent.fixedRateTimer


class NotificationService : Service() {

    val channelId: String = "ChannelId"

    lateinit var timer: Timer

    override fun onCreate() {
        super.onCreate()
        startTimer()
    }

    override fun onBind(intent: Intent): IBinder? {
        return null
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notificationManager =
            getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                channelId,
                packageName + "打卡",
                NotificationManager.IMPORTANCE_LOW
            )
            notificationManager.createNotificationChannel(channel)
        }
        startForeground(1, getNotification())
        return START_STICKY
    }

    private fun getNotification(): Notification {
        val contentIntent = Intent()
        contentIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        contentIntent.action = "android.settings.APPLICATION_DETAILS_SETTINGS"
        contentIntent.data = Uri.fromParts("package", packageName, null)
        val builder: Notification.Builder = Notification.Builder(this)
            .setSmallIcon(android.R.mipmap.sym_def_app_icon)
            .setContentIntent(PendingIntent.getActivity(this, 0, contentIntent, 0))
            .setContentTitle("\"$packageName\"正在运行")
            .setContentText("触摸即可了解详情或停止应用")
        //设置Notification的ChannelID,否则不能正常显示
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            builder.setChannelId(channelId)
        }
        return builder.build()
    }

    override fun onDestroy() {
        super.onDestroy()
        stopTimer()
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            stopForeground(STOP_FOREGROUND_REMOVE)
        }
        stopForeground(true)
    }

    private fun startTimer() {

        timer = fixedRateTimer("", false, 0, period * 1000) {
            try {
                // TODO: 根据条件执行任务
            } catch (e: Exception) {
                Log.i("TAG", "$e")
            }
        }
    }

    private fun stopTimer() {
        timer.cancel()
        Log.d("TAG", "stopTimer")
    }
}
```

</details>

# 方案二：利用闹钟定时发送广播，由静态广播接收消息唤醒App执行任务

1. `AndroidManifest.xml`文件添加receiver

<details>
<summary>点我展开</summary>

```xml
<receiver
    android:name=".ui.alarm.AlarmReceiver"
    android:enabled="true"
    android:exported="true" />
```

</details>

2. 定义receiver类

<details>
<summary>点我展开</summary>

```kotlin
class AlarmReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action.equals("${context.packageName}.alarm")) {
            try {
                // TODO: 根据条件执行任务
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}
```

</details>

3. 定义闹钟并开启

<details>
<summary>点我展开</summary>

```kotlin
val intent = Intent("$packageName.alarm")
intent.setClass(this, AlarmReceiver::class.java)
val pi = PendingIntent.getBroadcast(this, 0, intent, 0) //设置一个PendingIntent对象，发送广播
val alarmManager = getSystemService(ALARM_SERVICE) as AlarmManager //获取AlarmManager对象

if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
    val nextAlarmClock = alarmManager.nextAlarmClock
    if (nextAlarmClock != null) {
        val showIntent = nextAlarmClock.showIntent
        val triggerTime = nextAlarmClock.triggerTime
        Log.i("TAG", "init: $showIntent")
        Log.i("TAG", "init: $triggerTime")
    }
}

//AlarmManager.ELAPSED_REALTIME: 闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3; 
//AlarmManager.ELAPSED_REALTIME_WAKEUP: 闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2； 
//AlarmManager.RTC: 闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1； 
//AlarmManager.RTC_WAKEUP: 表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0; 
//AlarmManager.POWER_OFF_WAKEUP: 表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；

// 重复执行，倒数第二参数为间隔时间,单位为毫秒
alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, calendar.timeInMillis, intervalMillis * 1000, pi)

//时间到时，执行PendingIntent，只执行一次
alarmManager[AlarmManager.RTC_WAKEUP, calendar.timeInMillis] = pi
```

</details>

# 方案三：利用屏保服务阻止手机进入休眠，由定时任务唤醒目标App