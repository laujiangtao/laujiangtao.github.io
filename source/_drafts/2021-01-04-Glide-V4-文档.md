---
title: 【转载】Glide V4 文档
pathsuffix: glide-v4-doc
comments: false
date: 2021-01-04 14:10:46
tags: Android
category: 技术
---
原文链接：[点击查看](http://bumptech.github.io/glide/)

### 关于 Glide

Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（`decode pipeline`），以及自动的资源池技术。

![Glide logo](glide_logo.png?raw=true)

Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于`HttpUrlConnection`的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。

虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。

#### API

Glide 使用简明的流式语法API，这是一个非常棒的设计，因为它允许你在大部分情况下一行代码搞定需求：

```java
Glide.with(fragment)
    .load(url)
    .into(imageView);
```

#### 性能

Glide 充分考虑了Android图片加载性能的两个关键方面：

- 图片解码速度
- 解码图片带来的资源压力

为了让用户拥有良好的App使用体验，图片不仅要快速加载，而且还不能因为过多的主线程I/O或频繁的垃圾回收导致页面的闪烁和抖动现象。

Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：

- 自动、智能地下采样(`downsampling`)和缓存(`caching`)，以最小化存储开销和解码次数；
- 积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；
- 深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。

### 配置要求

Glide v4最低支持Android [Ice Cream Sandwich](https://developer.android.com/about/versions/android-4.0-highlights.html) (API level 14).



## 下载和设置 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/download-setup.html)

- [Android SDK 要求](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#android-sdk-要求)
- 下载
  - [Jar](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#jar)
  - [Gradle](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#gradle)
  - [Maven](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#maven)
- 设置
  - 权限
    - [Internet](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#internet)
    - [连接监听 (Connectivity Monitoring)](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#连接监听-connectivity-monitoring)
    - [本地存储 (Local Storage)](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#本地存储-local-storage)
  - [Proguard](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#proguard)
  - [Jack](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#jack)
  - [Java 8](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#java-8)
  - [Kotlin](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html#kotlin)

### Android SDK 要求

**Min Sdk Version** - 使用 Glide 需要 min SDK 版本 API **14** (Ice Cream Sandwich) 或更高。

**Compile Sdk Version** - Glide 必须使用 API **27** (Oreo MR1) 或更高版本的 SDK 来编译。

**Support Library Version** - Glide 使用的支持库版本为 **27**。

如果你需要使用不同的支持库版本，你需要在你的 `build.gradle` 文件里去从 Glide 的依赖中去除 `"com.android.support"`。例如，假如你想使用 v26 的支持库：

```groovy
dependencies {
  implementation ("com.github.bumptech.glide:glide:4.11.0") {
    exclude group: "com.android.support"
  }
  implementation "com.android.support:support-fragment:26.1.0"
}
```

使用与 Glide 依赖的支持库不同的版本可能会导致一些运行时异常 ，例如：

```
java.lang.NoSuchMethodError: No static method getFont(Landroid/content/Context;ILandroid/util/TypedValue;ILandroid/widget/TextView;)Landroid/graphics/Typeface; in class Landroid/support/v4/content/res/ResourcesCompat; or its super classes (declaration of 'android.support.v4.content.res.ResourcesCompat' 
at android.support.v7.widget.TintTypedArray.getFont(TintTypedArray.java:119)
```

也可能造成 Glide 的 API 生成器失败，从而不能正确地生成 `GlideApp` 类.

请参阅 [#2730](https://github.com/bumptech/glide/issues/2730) 获取这方面的更多信息。

### 下载

可以使用多种方法获取 Glide 的公开发行版。

#### Jar

你可以直接在 GitHub 下载[最新的 jar 包](https://github.com/bumptech/glide/releases/download/v3.6.0/glide-3.6.0.jar)。并且还需要包含 Android [v4支持库](http://developer.android.com/tools/support-library/features.html#v4) 的 jar 包。

#### Gradle

如果使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。同样，你还需要添加 Android 支持库的依赖。

```groovy
repositories {
  mavenCentral()
  maven { url 'https://maven.google.com' }
}

dependencies {
    compile 'com.github.bumptech.glide:glide:4.11.0'
    annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'
}
```

注意：如果可能，请尽量在你的依赖中避免使用 `@aar` 。如果你必须这么做，请添加 `transitive=true` 以确保所有必要的类都被包含到你的 API 中：

```groovy
dependencies {
    implementation ("com.github.bumptech.glide:glide:4.11.0@aar") {
        transitive = true
    }
}
```

在 Gradle 中，`@aar` 意味着 [“Artifact Only”](https://docs.gradle.org/current/userguide/dependency_management.html#ssub:artifact_dependencies)，默认情况下将排除所有依赖。

使用 `@aar` 而不使用 `transitive=true` ,将会排除 Glide 的依赖，并导致运行时异常，例如：

```
java.lang.NoClassDefFoundError: com.bumptech.glide.load.resource.gif.GifBitmapProvider
    at com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.<init>(ByteBufferGifDecoder.java:68)
    at com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.<init>(ByteBufferGifDecoder.java:54)
    at com.bumptech.glide.Glide.<init>(Glide.java:327)
    at com.bumptech.glide.GlideBuilder.build(GlideBuilder.java:445)
    at com.bumptech.glide.Glide.initializeGlide(Glide.java:257)
    at com.bumptech.glide.Glide.initializeGlide(Glide.java:212)
    at com.bumptech.glide.Glide.checkAndInitializeGlide(Glide.java:176)
    at com.bumptech.glide.Glide.get(Glide.java:160)
    at com.bumptech.glide.Glide.getRetriever(Glide.java:612)
    at com.bumptech.glide.Glide.with(Glide.java:684)
```

#### Maven

如果使用 Maven，同样可以添加对 Glide 的依赖。再次强调，你依旧需要添加 Android 支持库的依赖。

```xml
<dependency>
  <groupId>com.github.bumptech.glide</groupId>
  <artifactId>glide</artifactId>
  <version>4.11.0</version>
  <type>aar</type>
</dependency>
<dependency>
  <groupId>com.google.android</groupId>
  <artifactId>support-v4</artifactId>
  <version>r7</version>
</dependency>
<dependency>
  <groupId>com.github.bumptech.glide</groupId>
  <artifactId>compiler</artifactId>
  <version>4.11.0</version>
  <optional>true</optional>
</dependency>
```

### 设置

针对相应的构建配置，你可能还需要做一些额外的设置。

#### 权限

Glide 假定你要访问的数据都存储在你的应用中，不要求任何权限。也就是说，大部分应用从设备上（DCIM，图库，或SD卡的其他地方）或 Internet 上加载图片。因此，你可能需要包含一条或多条以下列出的权限，这取决于你的应用场景。

##### Internet

如果你计划从 URL 或一个网络连接中加载数据，你需要添加 `INTERNET` 和 `ACCESS_NETWORK_STATE` 权限到你的 `AndroidManifest.xml` 中：

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="your.package.name"

    <uses-permission android:name="android.permission.INTERNET"/>
    <!--
    Allows Glide to monitor connectivity status and restart failed requests if users go from a
    a disconnected to a connected network state.
    -->
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>

    <application>
      ...
    </application>
</manifest>
```

从技术上讲，`ACCESS_NETWORK_STATE` 对于 Glide 加载 URL 并不是必需的，但是它将帮助 Glide 处理 *片状网络(flaky network)* 和飞行模式。请继续阅读下面的连接监视章节以了解详情。

##### 连接监听 (Connectivity Monitoring)

如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 `ACCESS_NETWORK_STATE` 权限，Glide 将自动监听连接状态而不需要额外的改动。

你可以通过检查 `ConnectivityMonitor` 日志标签来验证 Glide 是否正在监听网络状态:

```
adb shell setprop log.tag.ConnectivityMonitor DEBUG
```

如果你成功添加了 `ACCESS_NETWORK_STATE` 权限，你将在 logcat 中看到类似这样的日志：

```
11-18 18:51:23.673 D/ConnectivityMonitor(16236): ACCESS_NETWORK_STATE permission granted, registering connectivity monitor
11-18 18:48:55.135 V/ConnectivityMonitor(15773): connectivity changed: false
11-18 18:49:00.701 V/ConnectivityMonitor(15773): connectivity changed: true
```

而如果权限缺失，你将看到一条错误：

```
11-18 18:51:23.673 D/ConnectivityMonitor(16236): ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor
```

##### 本地存储 (Local Storage)

要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 `READ_EXTERNAL_STORAGE` 权限：

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="your.package.name"

    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />

    <application>
      ...
    </application>
</manifest>
```

而如果要使用 [`ExternalPreferredCacheDiskCacheFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.html) 来将 Glide 的缓存存储到公有 SD 卡上，你还需要添加 `WRITE_EXTERNAL_STORAGE` 权限：

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="your.package.name"

    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application>
      ...
    </application>
</manifest>
```

#### Proguard

如果你有使用到 proguard，那么请把以下代码添加到你的 `proguard.cfg` 文件中：

```
-keep public class * implements com.bumptech.glide.module.GlideModule
-keep public class * extends com.bumptech.glide.module.AppGlideModule
-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {
  **[] $VALUES;
  public *;
}

如果你的 target API 低于 Android API 27，请添加：
​```pro
-dontwarn com.bumptech.glide.load.resource.bitmap.VideoDecoder
```

VideoDecoder 使用 API 27 的一些接口，这可能导致 proguard 发出警告，尽管这些 API 在旧版 Android 设备上根本不会被调用。

如果你使用 DexGuard 你可能还需要添加：

```pro
# for DexGuard only
-keepresourcexmlelements manifest/application/meta-data@value=GlideModule
```

#### Jack

Glide 的构建配置需要使用一些 [Jack](https://source.android.com/source/jack) 目前还不能支持的特性。并且由于 Jack 最近已经被标记为 [deprecated](https://android-developers.googleblog.com/2017/03/future-of-java-8-language-feature.html)，Glide 需要使用的特性可能在未来也不会被加入了。如果你希望使用 Java 8 编译，请看下文。

#### Java 8

从 Android Studio 3.0 和 Android Gradle plugin 3.0 版本开始，你可以使用 Java 8 来编译你的项目和 Glide 。关于更多详细信息，请访问 Android 开发者网站的 [Use Java 8 LaAnguage Features](https://developer.android.com/studio/write/java8-support.html) 。

Glide 本身没有使用，也不要求你使用 Java 8 来编译或在你项目中使用 Glide。Glide 最终肯定也将需要使用 Java 8 来编译，但是我们将尽量为开发者们留出时间来先更新他们自己的应用，因此看起来 Java 8 在未来的几个月或数年内都不会成为一个需求（截止 11/2017）。

#### Kotlin

如果你在 Kotlin 编写的类里使用 Glide 注解，你需要引入一个 `kapt` 依赖，以代替常规的 `annotationProcessor` 依赖：

```
dependencies {
  kapt 'com.github.bumptech.glide:compiler:4.11.0'
}
```

请注意，你还需要在你的 `build.gradle` 文件中包含 `kotlin-kapt`插件：

```
apply plugin: 'kotlin-kapt'
```

关于 Kotlin 的更多 api，可以查看 [Generated API](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#kotlin)。



## 开始使用 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/getting-started.html)

- [基本用法](https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html#基本用法)
- [在 Application 模块中的使用](https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html#在-application-模块中的使用)
- [定制请求](https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html#定制请求)
- [在 ListView 和 RecyclerView 中的使用](https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html#在-listview-和-recyclerview-中的使用)
- [非 View 目标](https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html#非-view-目标)
- [后台线程](https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html#后台线程)

### 基本用法

多数情况下，使用Glide加载图片非常简单，一行代码足矣：

```
Glide.with(fragment)
    .load(myUrl)
    .into(imageView);
```

取消加载同样很简单：

```
Glide.with(fragment).clear(imageView);
```

尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。实际上，当 [`Glide.with()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/Glide.html#with-android.app.Fragment-) 中传入的 Activity 或 Fragment 实例销毁时，Glide 会自动取消加载并回收资源。

### 在 Application 模块中的使用

在 Application 模块中，可创建一个添加有 `@GlideModule` 注解，继承自 `AppGlideModule` 的类。此类可生成出一个流式 API，内联了多种选项，和集成库中自定义的选项：

```
package com.example.myapp;

import com.bumptech.glide.annotation.GlideModule;
import com.bumptech.glide.module.AppGlideModule;

@GlideModule
public final class MyAppGlideModule extends AppGlideModule {}
```

生成的 API 默认名为 `GlideApp` ，与 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的子类包名相同。在 Application 模块中将 `Glide.with()` 替换为 `GlideApp.with()`，即可使用该 API 去完成加载工作。

```
GlideApp.with(fragment)
   .load(myUrl)
   .placeholder(placeholder)
   .fitCenter()
   .into(imageView);
```

可以访问 Glide 的 [generated API](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html) 页面来获得更多信息。

### 定制请求

Glide 提供了许多可应用于单一请求的选项，包括变换、过渡、缓存选项等。

默认选项可以直接应用于请求上：

```
Glide.with(fragment)
  .load(myUrl)
  .placeholder(placeholder)
  .fitCenter()
  .into(imageView);
```

选项也可以通过 `RequestOptions` 类来在多个请求之间共享：

```
RequestOptions sharedOptions = 
    new RequestOptions()
      .placeholder(placeholder)
      .fitCenter();

Glide.with(fragment)
  .load(myUrl)
  .apply(sharedOptions)
  .into(imageView1);

Glide.with(fragment)
  .load(myUrl)
  .apply(sharedOptions)
  .into(imageView2);
```

对于更高级的使用场景，通过使用 Glide 的 [generated API](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html)，Glide 的 API 还可以被更深度地定制以包含自定义的选项。

### 在 ListView 和 RecyclerView 中的使用

在 ListView 或 RecyclerView 中加载图片的代码和在单独的 View 中加载完全一样。Glide 已经自动处理了 View 的复用和请求的取消：

```
@Override
public void onBindViewHolder(ViewHolder holder, int position) {
    String url = urls.get(position);
    Glide.with(fragment)
        .load(url)
        .into(holder.imageView);
}
```

对 url 进行 null 检验并不是必须的，如果 url 为 null，Glide 会清空 View 的内容，或者显示 [placeholder Drawable](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#placeholder-int-) 或 [fallback Drawable](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#fallback-int-) 的内容。

Glide 唯一的要求是，对于任何可复用的 `View` 或 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/Target.html) ，如果它们在之前的位置上，用 Glide 进行过加载操作，那么在新的位置上要去执行一个新的加载操作，或调用 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-) API 停止 Glide 的工作。

```
@Override
public void onBindViewHolder(ViewHolder holder, int position) {
    if (isImagePosition(position)) {
        String url = urls.get(position);
        Glide.with(fragment)
            .load(url)
            .into(holder.imageView);
    } else {
        Glide.with(fragment).clear(holder.imageView);
        holder.imageView.setImageDrawable(specialDrawable);
    }
}
```

对 `View` 调用 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-) 或 `into(View)`，表明在此之前的加载操作会被取消，并且在方法调用完成后，Glide 不会改变 view 的内容。如果你忘记调用 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-)，而又没有开启新的加载操作，那么就会出现这种情况，你已经为一个 view 设置好了一个 `Drawable`，但该 view 在之前的位置上使用 Glide 进行过加载图片的操作，Glide 加载完毕后可能会将这个 view 改回成原来的内容。

这里的代码以 RecyclerView 的使用为例，但规则同样适用于 ListView。

### 非 View 目标

除了将 `Bitmap` 和 `Drawable` 加载到 `View` 之外，你也可以开始异步加载到你的自定义 `Target` 中：

```
Glide.with(context
  .load(url)
  .into(new CustomTarget<Drawable>() {
    @Override
    public void onResourceReady(Drawable resource, Transition<Drawable> transition) {
      // Do something with the Drawable here.
    }

    @Override
    public void onLoadCleared(@Nullable Drawable placeholder) {
      // Remove the Drawable provided in onResourceReady from any Views and ensure 
      // no references to it remain.
    }
  });
```

使用自定义 `Target` 有一些陷阱，所以请务必阅读 [目标文档页](https://muyangmin.github.io/glide-docs-cn/doc/targets.html) 的详细内容。

### 后台线程

在后台线程加载图片也是直接使用 [`submit(int, int)`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestBuilder.html#submit-int-int-)：

```
FutureTarget<Bitmap> futureTarget =
  Glide.with(context)
    .asBitmap()
    .load(url)
    .submit(width, height);

Bitmap bitmap = futureTarget.get();

// Do something with the Bitmap and then when you're done with it:
Glide.with(context).clear(futureTarget);
```

如果你不想让 `Bitmap` 和 `Drawable` 自身在后台线程中，你也可以使用和前台线程一样的方式来开始异步加载：

```
Glide.with(context)
  .asBitmap()
  .load(url)
  .into(new Target<Bitmap>() {
    ...
  });
```



## Generated API 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/generatedapi.html)

- [简介](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#简介)
- 开始使用
  - [有效使用范围](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#有效使用范围)
  - [Java](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#java)
  - [Kotlin](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#kotlin)
  - [Android Studio](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#android-studio)
- [使用 Generated API](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#使用-generated-api)
- GlideExtension
  - [GlideOption](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#glideoption)
  - [GlideType](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html#glidetype)

### 简介

Glide v4 使用 [注解处理器 (Annotation Processor)](https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html) 来生成出一个 API，它允许应用扩展 Glide 的 API并包含各种集成库提供的组件。

Generated API 模式的设计出于以下两个目的：

1. 集成库可以为 Generated API 扩展自定义选项。
2. 在 Application 模块中可将常用的选项组打包成一个选项在 Generated API 中使用

虽然以上所说的工作均可以通过手动创建 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 子类的方式来完成，但想将它用好更具有挑战，并且降低了 API 使用的流畅性。

### 开始使用

#### 有效使用范围

Generated API 目前仅可以在 Application 模块内使用。这一限制可以让我们仅持有一份 Generated API，而不是各个 Library 和 Application 中均有自己定义出来的 Generated API。这一做法会让 Generated API 的调用更简单，并确保 Application 模块中 Generated API 调用的选项在各处行为一致。这一限制在接下来的版本中也许会被取消（以实验性或其他的方式给出）。

#### Java

要在 Application 模块中使用 Generated API，你需要执行以下两步：

1. 添加 Glide 注解处理器的依赖：

   ```
   repositories {
     mavenCentral()
   }
   
   dependencies {
     annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'
   }
   ```

   参阅 [下载和设置](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html) 页面了解更多。

2. 在 Application 模块中包含一个 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的实现：

   ```
   package com.example.myapp;
   
   import com.bumptech.glide.annotation.GlideModule;
   import com.bumptech.glide.module.AppGlideModule;
   
   @GlideModule
   public final class MyAppGlideModule extends AppGlideModule {}
   ```

你不必去重写 `AppGlideModule` 中的任何一个方法。子类中完全可以不用写任何东西，它只需要继承 `AppGlideModule` 并且添加 `@GlideModule` 注解。

[`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的实现必须使用 [`@GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideModule.html) 注解标记。如果注解不存在，该 module 将不会被 Glide 发现，并且在日志中收到一条带有 `Glide` tag 的警告，表示 module 未找到。

**注意：** 程序库 (Library) **不** 应该包含 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现，详见 [配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#avoid-appglidemodule-in-libraries)。

#### Kotlin

如果你正在使用Kotlin，你可以选择：

1. 使用 Java 按前面所述实现所有的 Glide 注解类([`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html)， [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html)，以及 [`GlideExtension`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideExtension.html) )。

2. 使用 Kotlin 实现注解类，但需要添加一个 `kapt` 依赖以替换 Glide 的`annotationProcessor` 依赖：

   ```
   dependencies {
     kapt 'com.github.bumptech.glide:compiler:4.11.0'
   }
   ```

   注意，你还需要在你的 `build.gradle` 文件中包含 `kotlin-kapt` 插件：

   ```
   apply plugin: 'kotlin-kapt'
   ```

   此外，如果你有其他的注解处理器，它们都必须全部被从 `annotationProcessor` 转换为 `kapt`：

   ```
   dependencies {
     kapt "android.arch.lifecycle:compiler:1.0.0"
     kapt 'com.github.bumptech.glide:compiler:4.11.0'
   }
   ```

   关于`kapt`的使用，请查看[官方文档](https://kotlinlang.org/docs/reference/kapt.html)。

#### Android Studio

Android Studio 在大多数时候都可以正确地处理注解处理器 (annotation processor) 和 generated API。然而，当你第一次添加你的 `AppGlideModule` 或做了某些类型的修改后，你可能需要重新构建 (rebuild) 你的项目。 无论何时，如果你发现 API 没有被 import ，或看起来已经过期，你可以通过以下方法重新构建：

1. 打开 Build 菜单；
2. 点击 Rebuild Project。

### 使用 Generated API

Generated API 默认名为 `GlideApp` ，与 Application 模块中 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html)的子类包名相同。在 Application 模块中将 `Glide.with()` 替换为 `GlideApp.with()`，即可使用该 API 去完成加载工作：

```
GlideApp.with(fragment)
   .load(myUrl)
   .placeholder(R.drawable.placeholder)
   .fitCenter()
   .into(imageView);
```

与 `Glide.with()` 不同，诸如 `fitCenter()` 和 `placeholder()` 等选项在 Builder 中直接可用，并不需要再传入单独的 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 对象。

### GlideExtension

Glide Generated API 可在 Application 和 Library 中被扩展。扩展使用被注解的静态方法来添加新的选项、修改现有选项、甚至添加额外的类型支持。

[`@GlideExtension`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideExtension.html) 注解用于标识一个扩展 Glide API 的类。任何扩展 Glide API 的类都必须使用这个注解来标记，否则其中被注解的方法就会被忽略。

被 [`@GlideExtension`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideExtension.html) 注解的类应以工具类的思维编写。这种类应该有一个私有的、空的构造方法，应为 final 类型，并且仅包含静态方法。被注解的类可以含有静态变量，可以引用其他的类或对象。

在 Application 模块中可以根据需求实现任意多个被 [`@GlideExtension`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideExtension.html) 注解的类，在 Library 模块中同样如此。当 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 被发现时，所有有效的 [Glide 扩展类](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideExtension.html) 会被合并，所有的选项在 API 中均可以被调用。合并冲突会导致 Glide 的 Annotation Processor 抛出编译错误。

被 `@GlideExtention` 注解的类有两种扩展方式：

1. [`GlideOption`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideOption.html) - 为 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 添加一个自定义的选项。
2. [`GlideType`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideType.html) - 添加对新的资源类型的支持(GIF，SVG 等等)。

#### GlideOption

用 [`@GlideOption`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideOption.html) 注解的静态方法用于扩展 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 。`GlideOption` 可以：

1. 定义一个在 Application 模块中频繁使用的选项集合。
2. 创建新的选项，通常与 Glide 的 [`Option`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Option.html) 类一起使用。

要定义一个选项集合，你可以这么写：

```
@GlideExtension
public class MyAppExtension {
  // Size of mini thumb in pixels.
  private static final int MINI_THUMB_SIZE = 100;

  private MyAppExtension() { } // utility class

  @NonNull
  @GlideOption
  public static BaseRequestOptions<?> miniThumb(BaseRequestOptions<?> options) {
    return options
      .fitCenter()
      .override(MINI_THUMB_SIZE);
  }
```

这将会在 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 的子类中生成一个方法，类似这样：

```
public class GlideOptions extends RequestOptions {
  
  public GlideOptions miniThumb() {
    return (GlideOptions) MyAppExtension.miniThumb(this);
  }

  ...
}
```

你可以为方法任意添加参数，但要保证第一个参数为 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html)。

```
@GlideOption
public static BaseRequestOptions<?> miniThumb(BaseRequestOptions<?> options, int size) {
  return options
    .fitCenter()
    .override(size);
}
```

在自动生成的方法中新添的参数同样被加了进来：

```
public GlideOptions miniThumb(int size) {
  return (GlideOptions) MyAppExtension.miniThumb(this);
}
```

之后你就可以使用生成的 `GlideApp` 类调用你的自定义方法：

```
GlideApp.with(fragment)
   .load(url)
   .miniThumb(thumbnailSize)
   .into(imageView);
```

使用 `@GlideOption` 标记的方法应该为静态方法，并且返回值为 `BaseRequestOptions<?>`。请注意，这些生成的方法在标准的 `Glide` 和 `RequestOptions` 类里不可用，只存在于生成的等效类中。

#### GlideType

被 [`@GlideType`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideType.html) 注解的静态方法用于扩展 [`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html) 。被 `@GlideType` 注解的方法允许你添加对新的资源类型的支持，包括指定默认选项。

例如，为添加对 GIF 的支持，你可以添加一个被 `@GlideType` 注解的方法：

```
@GlideExtension
public class MyAppExtension {
  private static final RequestOptions DECODE_TYPE_GIF = decodeTypeOf(GifDrawable.class).lock();

  @NonNull
  @GlideType(GifDrawable.class)
  public static RequestBuilder<GifDrwable> asGif(RequestBuilder<GifDrawable> requestBuilder) {
    return requestBuilder
      .transition(new DrawableTransitionOptions())
      .apply(DECODE_TYPE_GIF);
  }
}
```

这样会生成一个包含对应方法的 [`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html) ：

```
public class GlideRequests extends RequesetManager {

  public GlideRequest<GifDrawable> asGif() {
    return (GlideRequest<GifDrawable> MyAppExtension.asGif(this.as(GifDrawable.class));
  }
  
  ...
}
```

之后你可以使用生成的 `GlideApp` 类调用你的自定义类型：

```
GlideApp.with(fragment)
  .asGif()
  .load(url)
  .into(imageView);
```

被 `@GlideType` 标记的方法必须使用 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 作为其第一个参数，这里的泛型 `<T>` 对应 [`@GlideType`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideType.html) 注解中传入的类。该方法应为静态方法，且返回值为 `RequestBuilder<T>` 。方法必须定义在一个被 [`@GlideExtension`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideExtension.html) 注解标记的类中。



## 占位符 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/placeholders.html)

- 类型
  - [占位符(Placeholder)](https://muyangmin.github.io/glide-docs-cn/doc/placeholders.html#占位符placeholder)
  - [错误符(Error)](https://muyangmin.github.io/glide-docs-cn/doc/placeholders.html#错误符error)
  - [后备回调符(Fallback)](https://muyangmin.github.io/glide-docs-cn/doc/placeholders.html#后备回调符fallback)
- FAQ
  - [占位符是异步加载的吗？](https://muyangmin.github.io/glide-docs-cn/doc/placeholders.html#占位符是异步加载的吗)
  - [变换是否会被应用到占位符上？](https://muyangmin.github.io/glide-docs-cn/doc/placeholders.html#变换是否会被应用到占位符上)
  - [在多个不同的View上使用相同的Drawable可行么？](https://muyangmin.github.io/glide-docs-cn/doc/placeholders.html#在多个不同的view上使用相同的drawable可行么)

### 类型

Glide允许用户指定三种不同类型的占位符，分别在三种不同场景使用：

- [placeholder](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#placeholder-int-)
- [error](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#error-int-)
- [fallback](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#fallback-int-)

#### 占位符(Placeholder)

占位符是当请求正在执行时被展示的 Drawable 。当请求成功完成时，占位符会被请求到的资源替换。如果被请求的资源是从内存中加载出来的，那么占位符可能根本不会被显示。如果请求失败并且没有设置 `error Drawable` ，则占位符将被持续展示。类似地，如果请求的url/model为 `null` ，并且 `error Drawable` 和 `fallback` 都没有设置，那么占位符也会继续显示。

```
Glide.with(fragment)
  .load(url)
  .placeholder(R.drawable.placeholder)
  .into(view);
```

Or:

```
Glide.with(fragment)
  .load(url)
  .placeholder(new ColorDrawable(Color.BLACK))
  .into(view);
```

#### 错误符(Error)

`error Drawable` 在请求永久性失败时展示。`error Drawable` 同样也在请求的url/model为 `null` ，且并没有设置 `fallback Drawable` 时展示。

```
Glide.with(fragment)
  .load(url)
  .error(R.drawable.error)
  .into(view);
```

Or:

```
Glide.with(fragment)
  .load(url)
  .error(new ColorDrawable(Color.RED))
  .into(view);
```

#### 后备回调符(Fallback)

`fallback Drawable` 在请求的url/model为 `null` 时展示。设计 `fallback Drawable` 的主要目的是允许用户指示 `null` 是否为可接受的正常情况。例如，一个 `null` 的个人资料 url 可能暗示这个用户没有设置头像，因此应该使用默认头像。然而，`null` 也可能表明这个元数据根本就是不合法的，或者取不到。 默认情况下Glide将 `null` 作为错误处理，所以可以接受 `null` 的应用应当显式地设置一个 `fallback Drawable` 。

使用 [generated API][4]：

```
Glide.with(fragment)
  .load(url)
  .fallback(R.drawable.fallback)
  .into(view);
```

Or:

```
Glide.with(fragment)
  .load(url)
  .fallback(new ColorDrawable(Color.GREY))
  .into(view);
```

### FAQ

##### 占位符是异步加载的吗？

No。占位符是在主线程从Android Resources加载的。我们通常希望占位符比较小且容易被系统资源缓存机制缓存起来。

##### 变换是否会被应用到占位符上？

No。Transformation仅被应用于被请求的资源，而不会对任何占位符使用。

在应用中包含必须在运行时做变换才能使用的图片资源是很不划算的。相反，在应用中包含一个确切符合尺寸和形状要求的资源版本几乎总是一个更好的办法。假如你正在加载圆形图片，你可能希望在你的应用中包含圆形的占位符。另外你也可以考虑自定义一个View来剪裁(clip)你的占位符，而达到你想要的变换效果。

##### 在多个不同的View上使用相同的Drawable可行么？

通常可以，但不是绝对的。任何无状态(`non-stateful`)的 Drawable（例如 `BitmapDrawable` ）通常都是ok的。但是有状态的 Drawable 不一样，在同一时间多个 View 上展示它们通常不是很安全，因为多个View会立刻修改(`mutate`) Drawable 。对于有状态的 Drawable ，建议传入一个资源ID，或者使用 `newDrawable()` 来给每个请求传入一个新的拷贝。



## 选项 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/options.html)

- [请求选项](https://muyangmin.github.io/glide-docs-cn/doc/options.html#请求选项)
- [RequestOptions](https://muyangmin.github.io/glide-docs-cn/doc/options.html#requestoptions)
- [过渡选项](https://muyangmin.github.io/glide-docs-cn/doc/options.html#过渡选项)
- RequestBuilder
  - [选择资源类型](https://muyangmin.github.io/glide-docs-cn/doc/options.html#选择资源类型)
  - [应用 RequestOptions](https://muyangmin.github.io/glide-docs-cn/doc/options.html#应用-requestoptions)
  - [缩略图 (Thumbnail) 请求](https://muyangmin.github.io/glide-docs-cn/doc/options.html#缩略图-thumbnail-请求)
  - [在失败时开始新的请求](https://muyangmin.github.io/glide-docs-cn/doc/options.html#在失败时开始新的请求)
- [组件选项](https://muyangmin.github.io/glide-docs-cn/doc/options.html#组件选项)

### 请求选项

Glide中的大部分设置项都可以直接应用在 `Glide.with()` 返回的 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 对象上。

可用的选项包括（但不限于）：

- 占位符(`Placeholders`)
- 转换(`Transformations`)
- 缓存策略(`Caching Strategies`)
- 组件特有的设置项，例如编码质量，或`Bitmap`的解码配置等。

例如，要应用一个 [`CenterCrop`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/CenterCrop.html) [转换](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Transformation.html)，你可以使用以下代码：

```
Glide.with(fragment)
    .load(url)
    .centerCrop()
    .into(imageView);
```

### RequestOptions

如果你想让你的应用的不同部分之间共享相同的加载选项，你也可以初始化一个新的 `RequestOptions` 对象，并在每次加载时通过 [`apply()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#apply-com.bumptech.glide.request.RequestOptions-) 方法传入这个对象：

```
RequestOptions cropOptions = new RequestOptions().centerCrop(context);
...
Glide.with(fragment)
    .load(url)
    .apply(cropOptions)
    .into(imageView);
```

[`apply()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#apply-com.bumptech.glide.request.RequestOptions-) 方法可以被调用多次，因此 `RequestOption` 可以被组合使用。如果 `RequestOptions` 对象之间存在相互冲突的设置，那么只有最后一个被应用的 `RequestOptions` 会生效。

### 过渡选项

[TransitionOptions](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/TransitionOptions.html) 用于决定你的加载完成时会发生什么。

使用 `TransitionOption` 可以应用以下变换：

- View淡入
- 与占位符交叉淡入
- 或者什么都不发生

如果不使用变换，你的图像将会“跳入”其显示位置，直接替换掉之前的图像。为了避免这种突然的改变，你可以淡入view，或者让多个Drawable交叉淡入，而这些都需要使用`TransitionOptions`完成。

例如，要应用一个交叉淡入变换：

```
import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;

Glide.with(fragment)
    .load(url)
    .transition(withCrossFade())
    .into(view);
```

不同于`RequestOptions`，`TransitionOptions`是特定资源类型独有的，你能使用的变换取决于你让Glide加载哪种类型的资源。

这样的结果是，假如你请求加载一个 `Bitmap` ，你需要使用 [BitmapTransitionOptions](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.html) ，而不是 [DrawableTransitionOptions](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.html) 。同样，当你请求加载 `Bitmap` 时，你只需要做简单的淡入，而不需要做复杂的交叉淡入。

### RequestBuilder

[RequestBuilder](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 是Glide中请求的骨架，负责携带请求的url和你的设置项来开始一个新的加载过程。

使用 `RequestBuilder` 可以指定：

- 你想加载的资源类型(Bitmap, Drawable, 或其他)
- 你要加载的资源地址(url/model)
- 你想最终加载到的View
- 任何你想应用的（一个或多个）`RequestOption` 对象
- 任何你想应用的（一个或多个）`TransitionOption` 对象
- 任何你想加载的缩略图 [`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-)

要构造一个 `RequestBuilder` 对象，你可以通过先调用 `Glide.with()`然后再调用某一个 `as` 方法来完成：

```
RequestBuilder<Drawable> requestBuilder = Glide.with(fragment).asDrawable();
```

或先调用 `Glide.with()` 然后 `load()`：

```
RequestBuilder<Drawable> requestBuilder = Glide.with(fragment).load(url);
```

#### 选择资源类型

`RequestBuilders` 是特定于它们将要加载的资源类型的。默认情况下你会得到一个 Drawable RequestBuilder ，但你可以使用 `as...` 系列方法来改变请求类型。例如，如果你调用了 `asBitmap()` ，你就将获得一个 `Bitmap``RequestBuilder` 对象，而不是默认的 Drawable RequestBuilder。

```
RequestBuilder<Bitmap> requestBuilder = Glide.with(fragment).asBitmap();
```

#### 应用 RequestOptions

前面提到，可以使用 [`apply()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#apply-com.bumptech.glide.request.RequestOptions-) 方法应用 `RequestOptions` ，使用 [`transition()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#transition-com.bumptech.glide.TransitionOptions-) 方法应用 `TransitionOptions` 。

```
RequestBuilder<Drawable> requestBuilder = Glide.with(fragment).asDrawable();
requestBuilder.apply(requestOptions);
requestBuilder.transition(transitionOptions);
```

RequestBuilder 也可以被复用于开始多个请求：

```
RequestBuilder<Drawable> requestBuilder =
        Glide.with(fragment)
            .asDrawable()
            .apply(requestOptions);

for (int i = 0; i < numViews; i++) {
   ImageView view = viewGroup.getChildAt(i);
   String url = urls.get(i);
   requestBuilder.load(url).into(view);
}
```

#### 缩略图 (Thumbnail) 请求

Glide 的 [`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) API 允许你指定一个 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 以与你的主请求并行启动。[`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) 会在主请求加载过程中展示。如果主请求在缩略图请求之前完成，则缩略图请求中的图像将不会被展示。[`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) API 允许你简单快速地加载图像的低分辨率版本，并且同时加载图像的无损版本，这可以减少用户盯着加载指示器 *【例如进度条–译者注】* 的时间。

[`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) API 对本地和远程图片都适用，尤其是当低分辨率缩略图存在于 Glide 的磁盘缓存时，它们将很快被加载出来。

[`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) API 使用起来相对简单：

```
Glide.with(fragment)
  .load(url)
  .thumbnail(Glide.with(fragment)
    .load(thumbnailUrl))
  .into(imageView);
```

只要你的 `thumbnailUrl` 指向的图片比你的主 `url` 的分辨率更低，它将会很好地工作。相当数量的加载 API 提供了不同的指定图片尺寸的方法，它们尤其适用于 [`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) API。

如果你仅仅想加载一个本地图像，或者你只有一个单独的远程 URL， 你仍然可以从缩略图 API 受益。请使用 Glide 的 [`override`](https://muyangmin.github.io/glide-docs-cn/javadocs/430/com/bumptech/glide/request/RequestOptions.html#override-int-int-) 或 [`sizeMultiplier`](https://muyangmin.github.io/glide-docs-cn/javadocs/420/com/bumptech/glide/request/RequestOptions.html#sizeMultiplier-float-) API 来强制 Glide 在缩略图请求中加载一个低分辨率图像：

```
int thumbnailSize = ...;
Glide.with(fragment)
  .load(localUri)
  .thumbnail(Glide.with(fragment)
    .load(localUri)
    .override(thumbnailSize))
  .into(view);
```

[`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/430/com/bumptech/glide/RequestBuilder.html#thumbnail-float-) 方法有一个简化版本，它只需要一个 `sizeMultiplier` 参数。如果你只是想为你的加载相同的图片，但尺寸为 `View` 或 `Target` 的某个百分比的话特别有用：

```
Glide.with(fragment)
  .load(localUri)
  .thumbnail(/*sizeMultiplier=*/ 0.25f)
  .into(imageView);
```

#### 在失败时开始新的请求

从 Glide 4.3.0 开始，你现在可以使用 [`error`](https://muyangmin.github.io/glide-docs-cn/javadocs/430/com/bumptech/glide/RequestBuilder.html#error-com.bumptech.glide.RequestBuilder-) API 来指定一个 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html)，以在主请求失败时开始一次新的加载。例如，在请求 `primaryUrl` 失败后加载 `fallbackUrl`：

```
Glide.with(fragment)
  .load(primaryUrl)
  .error(Glide.with(fragment)
      .load(fallbackUrl))
  .into(imageView);
```

如果主请求成功完成，这个[error](https://muyangmin.github.io/glide-docs-cn/javadocs/430/com/bumptech/glide/RequestBuilder.html#error-com.bumptech.glide.RequestBuilder-) [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 将不会被启动。如果你同时指定了一个 [`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) 和一个 [`error()`](https://muyangmin.github.io/glide-docs-cn/javadocs/430/com/bumptech/glide/RequestBuilder.html#error-com.bumptech.glide.RequestBuilder-) [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html)，则这个后备的 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 将在主请求失败时启动，即使缩略图请求成功也是如此。

### 组件选项

[`Option`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Option.html) 类是给Glide的组件添加参数的通用办法，包括 [`ModelLoaders`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoader.html) , [`ResourceDecoders`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/ResourceDecoder.html) , [`ResourceEncoders`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/ResourceEncoder.html) , [`Encoders`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Encoder.html) 等等。一些Glide的内置组件提供了设置项，自定义的组件也可以添加设置项。

`Option` 通过 `RequestOptions` 类应用到请求上：

```
Glide.with(context)
  .load(url)
  .option(MyCustomModelLoader.TIMEOUT_MS, 1000L)
  .into(imageView);
```

你也可以创建一个全新的 RequestOptions 对象：

```
RequestOptions options = new RequestOptions()
  .set(MyCustomModelLoader.TIMEOUT_MS, 1000L);

Glide.with(context)
  .load(url)
  .apply(options)
  .into(imageView);
```



## 变换 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/transformations.html)

- [关于变换](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#关于变换)
- [内置类型](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#内置类型)
- 应用
  - [默认变换](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#默认变换)
  - [多重变换](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#多重变换)
- 定制变换
  - [BitmapTransformation](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#bitmaptransformation)
  - [必需的方法](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#必需的方法)
  - [不要忘记 equals() / hashCode()!](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#不要忘记-equals--hashcode)
- Glide中的特殊行为
  - [重用变换](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#重用变换)
  - [ImageView的自动变换](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#imageview的自动变换)
  - [自定义资源](https://muyangmin.github.io/glide-docs-cn/doc/transformations.html#自定义资源)

### 关于变换

在Glide中，[Transformations](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Transformation.html) 可以获取资源并修改它，然后返回被修改后的资源。通常变换操作是用来完成剪裁或对位图应用过滤器，但它也可以用于转换GIF动画，甚至自定义的资源类型。

### 内置类型

Glide 提供了很多内置的变换，包括：

- [CenterCrop](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/CenterCrop.html)
- [FitCenter](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/FitCenter.html)
- [CircleCrop](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/CircleCrop.html)

### 应用

通过 [RequestOptions](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 类可以应用变换：

#### 默认变换

```
Glide.with(fragment)
  .load(url)
  .fitCenter()
  .into(imageView);
```

或使用 `RequestOptions` ：

```
RequestOptions options = new RequestOptions();
options.centerCrop();

Glide.with(fragment)
    .load(url)
    .apply(options)
    .into(imageView);
```

可以查阅 [Options](https://muyangmin.github.io/glide-docs-cn/doc/options.html) 页来获得更多 `RequestOption` 的相关信息。

#### 多重变换

默认情况下，每个 [`transform()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#transform-java.lang.Class-com.bumptech.glide.load.Transformation-) 调用，或任何特定转换方法(`fitCenter()`, `centerCrop()`, `bitmapTransform()` etc)的调用都会替换掉之前的变换。

如果你想在单次加载中应用多个变换，请使用 [`MultiTransformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/MultiTransformation.html) 类，或其快捷方法 [`.transforms()`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html#transforms-com.bumptech.glide.load.Transformation...-) 。

```
Glide.with(fragment)
  .load(url)
  .transform(new MultiTransformation(new FitCenter(), new YourCustomTransformation())
  .into(imageView);
```

或使用快捷方法：

```
Glide.with(fragment)
  .load(url)
  .transform(new FitCenter(), new YourCustomTransformation())
  .into(imageView);
```

请注意，你向 [`MultiTransformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/MultiTransformation.html) 的构造器传入变换参数的顺序，决定了这些变换的应用顺序。

### 定制变换

尽管 Glide 提供了各种各样的内置 [`Transformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Transformation.html) 实现，如果你需要额外的功能，你也可以实现你自己的 [`Transformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/FitCenter.html)。

#### BitmapTransformation

如果你只需要变换 `Bitmap`，最好是从继承 [`BitmapTransformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.html) 开始。`BitmapTransformation` 为我们处理了一些基础的东西，例如，如果你的变换返回了一个新修改的 Bitmap ，`BitmapTransformation`将负责提取和回收原始的 Bitmap。

一个简单的实现看起来可能像这样：

```
public class FillSpace extends BitmapTransformation {
    private static final String ID = "com.bumptech.glide.transformations.FillSpace";
    private static final String ID_BYTES = ID.getBytes(STRING_CHARSET_NAME);

    @Override
    public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {
        if (toTransform.getWidth() == outWidth && toTransform.getHeight() == outHeight) {
            return toTransform;
        }

        return Bitmap.createScaledBitmap(toTransform, outWidth, outHeight, /*filter=*/ true);
    }

    @Override
    public void equals(Object o) {
      return o instanceof FillSpace;
    }

    @Override
    public int hashCode() {
      return ID.hashCode();
    }

    @Override
    public void updateDiskCacheKey(MessageDigest messageDigest)
        throws UnsupportedEncodingException {
      messageDigest.update(ID_BYTES);
    }
}
```

尽管你的 `Transformation` 将几乎确定比这个示例更复杂，但它应该包含了相同的基本元素和复写方法。

#### 必需的方法

请特别注意，对于任何 `Transformation` 子类，包括 `BitmapTransformation`，你都有三个方法你 **必须** 实现它们，以使得磁盘和内存缓存正确地工作：

1. `equals()`
2. `hashCode()`
3. `updateDiskCacheKey`

如果你的 [`Transformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Transformation.html) 没有参数，通常使用一个包含完整包限定名的 `static` `final` `String` 来作为一个 ID，它可以构成 `hashCode()` 的基础，并可用于更新 `updateDiskCacheKey()` 传入的 `MessageDigest`。如果你的 [`Transformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Transformation.html) 需要参数而且它会影响到 `Bitmap` 被变换的方式，它们也必须被包含到这三个方法中。

例如，Glide 的 [`RoundedCorners`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/resource/bitmap/RoundedCorners.html) 变换接受一个 `int`，它决定了圆角的弧度。它的`equals()`, `hashCode()` 和 `updateDiskCacheKey` 实现看起来像这样：

```
  @Override
  public boolean equals(Object o) {
    if (o instanceof RoundedCorners) {
      RoundedCorners other = (RoundedCorners) o;
      return roundingRadius == other.roundingRadius;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Util.hashCode(ID.hashCode(),
        Util.hashCode(roundingRadius));
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(ID_BYTES);

    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();
    messageDigest.update(radiusData);
  }
```

原来的 `String` 仍然保留，但 `roundingRadius` 被包含到了三个方法中。这里，`updateDiskCacheKey` 方法还演示了你可以如何使用 `ByteBuffer` 来包含基本参数到你的 `updateDiskCacheKey` 实现中。

#### 不要忘记 equals() / hashCode()!

值得重申的一点是，为了让内存缓存正常地工作你是否必须实现 `equals()` 和 `hashCode()` 方法。很不幸，即使你没有复写这两个方法，`BitmapTransformation` 和 `Transformation` 也能通过编译，但这并不意味着它们能正常工作。我们正在探索一些方案，以使在 Glide 的未来版本中，使用默认的 `equals()` 和 `hashCode` 方法将抛出一个编译时错误。

### Glide中的特殊行为

#### 重用变换

`Transformation` 的设计初衷是无状态的。因此，在多个加载中复用 `Transformation` 应当总是安全的。创建一次 `Transformation` 并在多个加载中使用它，通常是很好的实践。

#### ImageView的自动变换

在Glide中，当你为一个 [ImageView](http://developer.android.com/reference/android/widget/ImageView.html) 开始加载时，Glide可能会自动应用 [FitCenter](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/FitCenter.html) 或 [CenterCrop](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/CenterCrop.html) ，这取决于view的 [ScaleType](http://developer.android.com/reference/android/widget/ImageView.ScaleType.html) 。如果 `scaleType` 是 `CENTER_CROP` , Glide 将会自动应用 `CenterCrop` 变换。如果 `scaleType` 为 `FIT_CENTER` 或 `CENTER_INSIDE` ，Glide会自动使用 `FitCenter` 变换。

当然，你总有权利覆写默认的变换，只需要一个带有 `Transformation` 集合的 [RequestOptions](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 即可。另外，你也可以通过使用 [`dontTransform()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#dontTransform--) 确保不会自动应用任何变换。

#### 自定义资源

因为 Glide 4.0 允许你指定你将解码的资源的父类型，你可能无法确切地知道将会应用何种变换。例如，当你使用 [`asDrawable()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html#asDrawable--) (或就是普通的 `with()` ，因为 `asDrawable()` 是默认情形)来加载 Drawable 资源时，你可能会得到 [`BitmapDrawable`](http://developer.android.com/reference/android/graphics/drawable/BitmapDrawable.html) 子类，也有可能得到 [`GifDrawable`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/gif/GifDrawable.html) 子类。

为了确保你添加到 `RequestOptions` 中的任何变换都会被使用，Glide将 `Transformation` 添加到一个Map中保存，其Key为你提供变换的资源类型。当资源被成功解码时，Glide使用这个Map来取回对应的 `Transformation` 。

Glide可以将 `Bitmap` `Transformation`应用到 `BitmapDrawable` , `GifDrawable` , 以及 `Bitmap` 资源上，因此通常你只需要编写和应用 `Bitmap` `Transformation` 。然而，如果你添加了额外的资源类型，你可能需要考虑派生 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 类，并且，在内置的这些 `Bitmap` `Transformations` 之外，你还需要为你的自定义资源类型提供一个 `Transformation` 。



## 目标 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/targets.html)

- [关于Target](https://muyangmin.github.io/glide-docs-cn/doc/targets.html#关于target)
- [指定目标](https://muyangmin.github.io/glide-docs-cn/doc/targets.html#指定目标)
- 取消和重用
  - [清理](https://muyangmin.github.io/glide-docs-cn/doc/targets.html#清理)
- 尺寸 (Sizes and dimensions)
  - View 目标
    - [强大的尺寸管理](https://muyangmin.github.io/glide-docs-cn/doc/targets.html#强大的尺寸管理)
    - [后备方案](https://muyangmin.github.io/glide-docs-cn/doc/targets.html#后备方案)
  - [定制目标](https://muyangmin.github.io/glide-docs-cn/doc/targets.html#定制目标)
- [动画资源和定制目标](https://muyangmin.github.io/glide-docs-cn/doc/targets.html#动画资源和定制目标)

### 关于Target

在Glide中，[`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/Target.html) 是介于请求和请求者之间的中介者的角色。Target 负责展示占位符，加载资源，并为每个请求决定合适的尺寸。被使用得最频繁的是 [`ImageViewTargets`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/ImageViewTarget.html) ，它用于在 ImageView 上展示占位符、Drawable 和 Bitmap 。用户还可以实现自己的 Target ，或者从任何可用的基类派生子类。

### 指定目标

[`into(Target)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-Y-) 方法不仅仅用于启动每个请求，它同时也指定了接收请求结果的 Target：

```
Target<Drawable> target = 
  Glide.with(fragment)
    .load(url)
    .into(new Target<Drawable>() {
      ...
    });
```

Glide 提供了一个辅助方法 [`into(ImageView)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-android.widget.ImageView-) ，它接受一个 `ImageView` 参数并为其请求的资源类型包装了一个合适的 [`ImageViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/ImageViewTarget.html)：

```
Target<Drawable> target = 
  Glide.with(fragment)
    .load(url)
    .into(imageView);
```

### 取消和重用

你可以注意到 [`into(Target)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-Y-) 和 [`into(ImageView)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-android.widget.ImageView-) 都返回了一个 `Target` 实例。如果你重用这个 `Target` 来在将来开始一个新的加载，则之前开始的任何请求都会被取消，它们使用的资源将被释放：

```
Target<Drawable> target = 
  Glide.with(fragment)
    .load(url)
    .into(new Target<Drawable>() {
      ...
    });
... 
// Some time in the future:
Glide.with(fragment)
  .load(newUrl)
  .into(target);
```

你也可以使用返回的 `Target` 来 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-) 之前的加载，这将在不需要开始新的加载的情况下释放掉任何相关资源：

```
Target<Drawable> target = 
  Glide.with(fragment)
    .load(url)
    .into(new Target<Drawable>() {
      ...
    });
... 
// Some time in the future:
Glide.with(fragment).clear(target);
```

Glide 的 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html) 子类使用了 Android Framework 的 [`getTag()`](https://developer.android.com/reference/android/view/View.html#getTag()) 和 [`setTag()`](https://developer.android.com/reference/android/view/View.html#setTag(java.lang.Object)) 方法来存储每个请求的相关信息，因此如果你在使用 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html) 或在往 `ImageView` 中加载图片，你可以直接重用或清理这个 `View`:

```
Glide.with(fragment)
  .load(url)
  .into(imageView);

// Some time in the future:
Glide.with(fragment).clear(imageView);

// Or:
Glide.with(fragment)
  .load(newUrl)
  .into(imageView);
```

此外，**仅对[`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html)而言**，你可以在每次加载或清理调用时都传入一个新的实例，而 Glide 仍然可以从 `View` 的 tag 中取回之前一次加载的信息：

```
Glide.with(fragment)
  .load(url)
  .into(new DrawableImageViewTarget(imageView));

// Some time in the future:
Glide.with(fragment)
  .load(newUrl)
  .into(new DrawableImageViewTarget(imageView));
```

注意，除非你的 `Target` 继承自 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html)，或实现了 [`setRequest()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#setRequest-com.bumptech.glide.request.Request-) 和 [`getRequest()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#getRequest--)并允许你从新的 `Target` 实例中取回上一次加载的信息，否则这种使用方法将**不**奏效。

#### 清理

当你完成了对资源（`Bitmap`，`Drawable` 等）的使用时，及时清理（[`clear`](https://muyangmin.github.io/glide-docs-cn/doc/14)）你创建的这些 `Target` 是一个好的实践。即使你认为你的请求已经完成了，也应该使用 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-) 以使 Glide 可以重用被这次加载使用的任何资源 (特别是 Bitmap )。未调用 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-) 会浪费 CPU 和内存，阻塞更重要的加载，甚至如果你在同一个 surface (View, Notification, RPC 等) 上有两个 `Target`，可能会引发图片显示错误。对于像 [`SimpleTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/SimpleTarget.html)这种无法从一个新实例里跟踪前一个请求的 `Target` 来说，及时清理尤为重要。

### 尺寸 (Sizes and dimensions)

默认情况下，Glide 使用目标通过 [`getSize`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/Target.html#getSize-com.bumptech.glide.request.target.SizeReadyCallback-) 方法提供的尺寸来作为请求的目标尺寸。这允许 Glide 选取合适的 URL，下采样，裁剪和变换合适的图片以减少内存占用，并确保加载尽可能快地完成。

#### View 目标

[`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html) 通过检查 View 的属性和/或使用一个 [`OnPreDrawListener`](https://developer.android.com/reference/android/view/ViewTreeObserver.OnPreDrawListener.html) 在 View 绘制之前直接测量尺寸来实现 [`getSize()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/Target.html#getSize-com.bumptech.glide.request.target.SizeReadyCallback-) 方法。因此， Glide 可以自动调整大部分图片以匹配目标 `View`。加载更小的图片可使 Glide 更快地完成加载 (在缓存到磁盘以后)，并使用更少的内存，在图片尺寸一致时还可以增加 Glide 的 BitmapPool 的命中率。

`ViewTarget` 使用以下逻辑：

1. 如果 `View` 的布局参数尺寸 > 0 且 > padding，则使用该布局参数；
2. 如果 `View` 尺寸 > 0 且 > padding，使用该实际尺寸；
3. 如果 `View` 布局参数为 `wrap_content` 且至少已发生一次 layout ，则打印一行警告日志，建议使用 `Target.SIZE_ORIGINAL` 或通过 `override()` 指定其他固定尺寸，并使用屏幕尺寸为该请求尺寸；
4. 其他情况下（布局参数为 `match_parent`， `0`， 或 `wrap_content` 且没有发生过 layout ），则等待布局完成，然后回溯到步骤1。

有时在使用 `RecyclerView`时，`View` 可能被重用且保持了前一个位置的尺寸，但在当前位置会发生改变。为了处理这种场景，你可以创建一个新的 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html) 并为 `waitForLayout()` 方法传入 true：

```
@Override
public void onBindViewHolder(VH holder, int position) {
  Glide.with(fragment)
    .load(urls.get(position))
    .into(new DrawableImageViewTarget(holder.imageView, /*waitForLayout=*/ true));
```

##### 强大的尺寸管理

通常 Glide 在显式地为加载的 View 设置了 dp 尺寸时提供了最快且最可预测的结果。如果无法达到这一点，Glide 也通过 `onPreDrawListener` 提供了为 `layout_weight`，`match_parent` 和其他相对尺寸的完备鲁棒的支持。最后，如果这些都无法达成，Glide 应该也为 `wrap_content` 提供了合理的行为。

##### 后备方案

在任何情况下，如果 Glide 看起来获取了错误的 View 尺寸，你都可以手动覆盖来纠正它。你可以选择扩展 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/ViewTarget.html) 实现你自己的逻辑，或者使用 `RequestOption` 里的 [`override()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#override-int-int-)方法。

#### 定制目标

如果你正在使用一个 `Target` 且你将要加载的不是可以允许你派生 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html) 的 View, 你讲需要实现 [`getSize()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/Target.html#getSize-com.bumptech.glide.request.target.SizeReadyCallback-) 方法。

实现 `getSize` 可能最简单的方案是直接调用回调：

```
@Override
public void getSize(SizeReadyCallback cb) {
  cb.onSizeReady(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
}
```

使用 `Target.SIZE_ORIGINAL` 可能非常低效，或如果你的图片足够大可能引发 OOM 。作为替代方案，你也可以为你的 `Target` 的构造器传入一个尺寸，并把这些尺寸提供给回调：

```
public class CustomTarget<T> implements Target<T> {
  private final int width;
  private final int height;
 
  public CustomTarget(int width, int height) {
    this.width = width;
    this.height = height;
  }

  ...

  @Override
  public void getSize(SizeReadyCallback cb) {
    cb.onSizeReady(width, height);
  }
}
```

如果你的应用内使用一致的图片尺寸，或你确切地知道你需要的尺寸，你也可以传入一个特定尺寸的集合。如果你不知道所需的具体尺寸，但可以异步地得出结果，你也可以使用列表持有在 [`getSize()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/Target.html#getSize-com.bumptech.glide.request.target.SizeReadyCallback-) 中给出你的任何回调，然后执行你的异步过程并稍后在你得出尺寸之后通知你持有的这些回调。

如果你持有了这些回调，请确保同时实现 [`removeCallback`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#removeCallback-com.bumptech.glide.request.target.SizeReadyCallback-) 以避免内存泄露。

如果需要一个示例，请参考 [`ViewTarget`](https://github.com/bumptech/glide/blob/e9cf41fbc190c9d29ce683728f52c061809c749b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java#L89) 中的逻辑。

### 动画资源和定制目标

如果你只是要加载 `GifDrawable`，或任何其他资源类型到一个 `View`，你应该总是尽可能地使用 `into(ImageView)`。除了优雅的处理或新发起请求之外，Glide的大部分 `ViewTarget` 实现已经为您处理了 `Drawable` 动画。如果你确实必须使用定制的 `ViewTarget`，请确保继承自 `ViewTarget` 或在新请求开始之前和展示资源结束之后严格地清理从 `into(Target)` 返回的 `Target`。

如果你并非往 `View` 中加载图片，而直接使用 `ViewTarget` 或使用了定制的 `Target` 比如 [`SimpleTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/SimpleTarget.html) 且你正在加载一个动画资源例如 [`GifDrawable`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/resource/gif/GifDrawable.html)，你需要确保在 `onResourceReady` 中调用 [`start()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/resource/gif/GifDrawable.html#start--) 来启动这个动画：

```
Glide.with(fragment)
  .asGif()
  .load(url)
  .into(new SimpleTarget<>() {
    @Override
    public void onResourceReady(GifDrawable resource, Transition<GifDrawable> transition) {
      resource.start();
      // Set the resource wherever you need to use it.
    }
  });
```

如果你加载的是 `Bitmap` 或 `GifDrawable`，你可以判断这个可绘制对象是否实现了 [`Animatable`](https://developer.android.com/reference/android/graphics/drawable/Animatable.html)：

```
Glide.with(fragment)
  .load(url)
  .into(new SimpleTarget<>() {
    @Override
    public void onResourceReady(Drawable resource, Transition<GifDrawable> transition) {
      if (resource instanceof Animatable) {
        resource.start();
      }
      // Set the resource wherever you need to use it.
    }
  });
```



## 过渡 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/transitions.html)

- [关于过渡](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#关于过渡)
- [默认过渡](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#默认过渡)
- [标准行为](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#标准行为)
- [指定过渡](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#指定过渡)
- [性能提示](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#性能提示)
- 常见错误
  - [对占位符和透明图片交叉淡入](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#对占位符和透明图片交叉淡入)
  - [在多个请求间交叉淡入](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#在多个请求间交叉淡入)
- [定制过渡](https://muyangmin.github.io/glide-docs-cn/doc/transitions.html#定制过渡)

### 关于过渡

在 Glide 中，[`Transitions`(直译为”过渡”)](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/transition/Transition.html) 允许你定义 Glide 如何从占位符到新加载的图片，或从缩略图到全尺寸图像过渡。Transition 在单一请求的上下文中工作，而不会跨多个请求。因此，[`Transitions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/transition/Transition.html) 并不能让你定义从一个请求到另一个请求的动画（比如，交叉淡入效果）。

### 默认过渡

不同于 Glide v3，Glide v4 将**不会**默认应用交叉淡入或任何其他的过渡效果。每个请求必须手动应用过渡。

### 标准行为

Glide 提供了很多的过渡效果，用户可以手动地应用于每个请求。Glide 的内置过渡以一致的方式运行，并且将根据加载图像的位置在某些情况下避免运行。

在 Glide 中，图像可能从四个地方中的任何一个位置加载出来：

1. Glide 的内存缓存
2. Glide 的磁盘缓存
3. 设备本地可用的一个源文件或 Uri
4. 仅远程可用的一个源 Url 或 Uri

如果图像从 Glide 的内存缓存中加载出来，Glide 的内置过渡将不会执行。然而，在另外三种场景下，Glide 的内置过渡都会被执行。

要改变这种行为并编写你自己的定制过渡，请阅读接下来的 [custom transitions](https://muyangmin.github.io/glide-docs-cn/transitions#custom-transitions) 章节。

### 指定过渡

你可以查看 [Options documentation](https://muyangmin.github.io/glide/doc/options.html#transitionoptions) 以获取概览和示例代码。

[`TransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/TransitionOptions.html) 用于给一个特定的请求指定过渡。 每个请求可以使用 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 中的 [`transition()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#transition-com.bumptech.glide.TransitionOptions-) 方法来设定 [`TransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/TransitionOptions.html) 。还可以通过使用 [`BitmapTransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.html) 或 [`DrawableTransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.html) 来指定类型特定的过渡动画。对于 Bitmap 和 Drawable 之外的资源类型，可以使用 [`GenericTransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/GenericTransitionOptions.html)。

### 性能提示

Android中的动画代价是比较大的，尤其是同时开始大量动画的时候。 交叉淡入和其他涉及 alpha 变化的动画显得尤其昂贵。 此外，动画通常比图片解码本身还要耗时。在列表和网格中滥用动画可能会让图像的加载显得缓慢而卡顿。为了提升性能，请在使用 Glide 向 ListView , GridView, 或 RecyclerView 加载图片时考虑避免使用动画，尤其是大多数情况下，你希望图片被尽快缓存和加载的时候。作为替代方案，请考虑预加载，这样当用户滑动到具体的 item 的时候，图片已经在内存中了。

### 常见错误

#### 对占位符和透明图片交叉淡入

Glide 的默认交叉淡入(cross fade)效果使用了 [`TransitionDrawable`](https://developer.android.com/reference/android/graphics/drawable/TransitionDrawable.html) 。它提供两种动画模式，由 [`setCrossFadeEnabled()`](https://developer.android.com/reference/android/graphics/drawable/TransitionDrawable.html#setCrossFadeEnabled(boolean)) 控制。当交叉淡入被禁用时，正在过渡的图片会在原先显示的图像上面淡入。当交叉淡入被启用时，原先显示的图片会从不透明过渡到透明，而正在过渡的图片则会从透明变为不透明。

在 Glide 中，我们默认禁用了交叉淡入，这样通常看起来要好看一些。实际的交叉淡入，如上所述对两个图片同时改变 alpha 值，通常会在过渡的中间造成一个短暂的白色闪屏，这个时候两个图片都是部分不透明的。

不幸的是，虽然禁用交叉淡入通常是一个比较好的默认行为，当待加载的图片包含透明像素时仍然可能造成问题。当占位符比实际加载的图片要大，或者图片部分为透明时，禁用交叉淡入会导致动画完成后占位符在图片后面仍然可见。如果你在加载透明图片时使用了占位符，你可以启用交叉淡入，具体办法是调整 [`DrawableCrossFadeFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.html) 里的参数并将结果传到 [`transition()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/TransitionOptions.html#transition-com.bumptech.glide.request.transition.TransitionFactory-) 中：

```
DrawableCrossFadeFactory factory =
        new DrawableCrossFadeFactory.Builder().setCrossFadeEnabled(true).build();

GlideApp.with(context)
        .load(url)
        .transition(withCrossFade(factory))
        .diskCacheStrategy(DiskCacheStrategy.ALL)
        .placeholder(R.color.placeholder)
        .into(imageView);
```

更多信息参见 [Issue #2017](https://github.com/bumptech/glide/issues/2017)。感谢 @minas90 编写以上的示例代码。

#### 在多个请求间交叉淡入

[`Transitions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/transition/Transition.html) 并不能让你在不同请求中加载的两个图像之间做过渡。当新的加载被应用到 View 或 Target (查看 [Target的文档](https://muyangmin.github.io/glide/doc/targets.html#targets-and-automatic-cancellation) )上时，Glide 默认会取消任何已经存在的请求。因此，如果你想加载连个个不同的图片并在它们之间做动画，你无法直接通过 Glide 来完成。等待第一个加载完成并在 View 外持有这个 Bitmap 或 Drawable ，然后开始新的加载并手动在这两者之间做动画，诸如此类的策略看起来有效，但是实际上不安全，并可能导致程序崩溃或图像错误。

相反，最简单的办法是使用包含两个 [`ImageView`](https://developer.android.com/reference/android/widget/ImageView.html) 的 [`ViewSwitcher`](https://developer.android.com/reference/android/widget/ViewSwitcher.html) 来完成。将第一张图片加载到 [`getNextView()`](https://developer.android.com/reference/android/widget/ViewSwitcher.html#getNextView()) 的返回值里面，然后将第二张图片加载到 [`getNextView()`](https://developer.android.com/reference/android/widget/ViewSwitcher.html#getNextView()) 的下一个返回值中，并使用一个 [`RequestListener`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestListener.html) 在第二张图片加载完成时调用 [`showNext()`](https://developer.android.com/reference/android/widget/ViewAnimator.html#showNext()) 。为了更好地控制，你也可以使用 [Android开发者文档](https://developer.android.com/training/animation/crossfade.html) 指出的策略。但要记住与 [`ViewSwitcher`](https://developer.android.com/reference/android/widget/ViewSwitcher.html) 一样，仅在第二次图像加载完成后才开始交叉淡入淡出。

### 定制过渡

如果要定义一个自定义的过渡动画，你需要完成以下两个步骤：

1. 实现 [`TransitionFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/transition/TransitionFactory.html) .
2. 使用 [`DrawableTransitionOptions#with`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.html#with-com.bumptech.glide.request.transition.TransitionFactory-) 来将你自定义的 `TransitionFactory` 应用到加载中。

如果要改变你的 transition 的默认行为，以更好地控制它在不同的加载源（内存缓存，磁盘缓存，或uri）下是否被应用，你可以检查一下你的 [`TransitionFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/transition/TransitionFactory.html) 中传递给 [`build()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/transition/TransitionFactory.html#build-com.bumptech.glide.load.DataSource-boolean-) 方法的那个 [`DataSource`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/DataSource.html) 。

如需示例代码，请查看 [`DrawableCrossFadeFactory`](https://github.com/bumptech/glide/blob/8f22bd9b82349bf748e335b4a31e70c9383fb15a/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java#L35).



## 配置 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/configuration.html)

- 设置
  - [应用程序](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#应用程序)
  - 程序库 (Libraries)
    - [避免在程序库中使用 AppGlideModule](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#避免在程序库中使用-appglidemodule)
- 应用程序选项
  - [内存缓存](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#内存缓存)
  - [Bitmap 池](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#bitmap-池)
  - [磁盘缓存](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#磁盘缓存)
- [默认请求选项](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#默认请求选项)
- 未捕获异常策略 (UncaughtThrowableStrategy)
  - [日志级别](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#日志级别)
- [注册组件](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#注册组件)
- [剖析(Anatomy)一个请求](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#剖析anatomy一个请求)
- 排序组件
  - [prepend()](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#prepend)
  - [append()](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#append)
  - [replace()](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#replace)
  - [添加一个 ModelLoader](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#添加一个-modelloader)
- 模块类和注解
  - [AppGlideModule](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#appglidemodule)
  - [@GlideModule](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#glidemodule)
  - [注解处理器](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#注解处理器)
- [冲突](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#冲突)
- [清单解析](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#清单解析)

### 设置

从 Glide 4.9.0 开始，在某些情形下必须完成必要的设置 (`setup`)。

对于应用程序（application），仅当以下情形时才需要做设置：

- 使用一个或更多集成库
- 修改 Glide 的配置(`configuration`)（磁盘缓存大小/位置，内存缓存大小等）
- 扩展 Glide 的API。

对于库（library），仅当库需要注册一个或多个组件时才需要做设置。

#### 应用程序

应用程序(Applications)如果希望使用集成库和/或 Glide 的 API 扩展，则需要：

1. 恰当地添加一个 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现。
2. (可选)添加一个或多个 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 实现。
3. 给上述两种实现添加 [`@GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideModule.html) 注解。
4. 添加对 Glide 的注解解析器的依赖。
5. 在 proguard 中，添加对 [`AppGlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的 keep 。

在 Glide 的 [Flickr 示例应用](https://github.com/bumptech/glide/blob/master/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java) 中，有一个 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的示例实现：

```
@GlideModule
public class FlickrGlideModule extends AppGlideModule {
  @Override
  public void registerComponents(Context context, Registry registry) {
    registry.append(Photo.class, InputStream.class, new FlickrModelLoader.Factory());
  }
}
```

请注意添加对 Glide 的注解和注解解析器的依赖：

```
compile 'com.github.bumptech.glide:annotations:4.11.0'
annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'
```

最后，你应该在你的 `proguard.cfg` 中 keep 住你的 AppGlideModule 实现：

```
-keep public class  extends com.bumptech.glide.module.AppGlideModule
-keep class com.bumptech.glide.GeneratedAppGlideModuleImpl
```

#### 程序库 (Libraries)

程序库若不需要注册定制组件，则不需要做任何配置步骤，可以完全跳过这个章节。

程序库如果需要注册定制组件，例如 `ModelLoader`，可按以下步骤执行：

1. 添加一个或多个 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 实现，以注册新的组件。
2. 为每个 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 实现，添加 [`@GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideModule.html) 注解。
3. 添加 Glide 的注解处理器的依赖。

一个 [`LibraryGlideModule`] 的例子，在 Glide 的[OkHttp 集成库](https://github.com/bumptech/glide/blob/master/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java) 中：

```
@GlideModule
public final class OkHttpLibraryGlideModule extends LibraryGlideModule {
  @Override
  public void registerComponents(Context context, Glide glide, Registry registry) {
    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
  }
}
```

使用 [`GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideModule.html) 注解需要使用 Glide 注解的依赖：

```
compile 'com.github.bumptech.glide:annotations:4.11.0'
```

##### 避免在程序库中使用 AppGlideModule

程序库一定 **不要** 包含 `AppGlideModule` 实现。这么做将会阻止依赖该库的任何应用程序管理它们的依赖，或配置诸如 Glide 缓存大小和位置之类的选项。

此外，如果两个程序库都包含 `AppGlideModule`，应用程序将无法在同时依赖两个库的情况下通过编译，而不得不在二者之中做出取舍。

这确实意味着程序库将无法使用 Glide 的 generated API，但是使标准的 `RequestBuilder` 和 `RequestOptions` 加载仍然有效（可以在 [选项](https://muyangmin.github.io/glide-docs-cn/doc/options.html) 页找到例子）。

### 应用程序选项

Glide 允许应用通过 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现来完全控制 Glide 的内存和磁盘缓存使用。Glide 试图提供对大部分应用程序合理的默认选项，但对于部分应用，可能就需要定制这些值。在你做任何改变时，请注意测量其结果，避免出现性能的倒退。

#### 内存缓存

默认情况下，Glide使用 [`LruResourceCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/LruResourceCache.html) ，这是 [`MemoryCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemoryCache.html) 接口的一个缺省实现，使用固定大小的内存和 LRU 算法。[`LruResourceCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/LruResourceCache.html) 的大小由 Glide 的 [`MemorySizeCalculator`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.html) 类来决定，这个类主要关注设备的内存类型，设备 RAM 大小，以及屏幕分辨率。

应用程序可以自定义 [`MemoryCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemoryCache.html) 的大小，具体是在它们的 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 中使用 [`applyOptions(Context, GlideBuilder)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html#applyOptions-android.content.Context-com.bumptech.glide.GlideBuilder-) 方法配置 [`MemorySizeCalculator`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.html) ：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context)
        .setMemoryCacheScreens(2)
        .build();
    builder.setMemoryCache(new LruResourceCache(calculator.getMemoryCacheSize()));
  }
}
```

也可以直接覆写缓存大小：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    int memoryCacheSizeBytes = 1024 * 1024 * 20; // 20mb
    builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));
  }
}
```

甚至可以提供自己的 [`MemoryCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemoryCache.html) 实现：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setMemoryCache(new YourAppMemoryCacheImpl());
  }
}
```

#### Bitmap 池

Glide 使用 [`LruBitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.html) 作为默认的 [`BitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.html) 。[`LruBitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.html) 是一个内存中的固定大小的 `BitmapPool`，使用 LRU 算法清理。默认大小基于设备的分辨率和密度，同时也考虑内存类和 [`isLowRamDevice`](https://developer.android.com/reference/android/app/ActivityManager.html#isLowRamDevice()) 的返回值。具体的计算通过 Glide 的 [`MemorySizeCalculator`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.html) 来完成，与 Glide 的 [`MemoryCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemoryCache.html) 的大小检测方法相似。

应用可以在它们的 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 中定制 [`BitmapPool`] 的尺寸，使用 [`applyOptions(Context, GlideBuilder)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html#applyOptions-android.content.Context-com.bumptech.glide.GlideBuilder-) 方法并配置 [`MemorySizeCalculator`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.html):

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context)
        .setBitmapPoolScreens(3)
        .build();
    builder.setBitmapPool(new LruBitmapPool(calculator.getBitmapPoolSize()));
  }
}
```

应用也可以直接复写这个池的大小：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    int bitmapPoolSizeBytes = 1024 * 1024 * 30; // 30mb
    builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));
  }
}
```

甚至可以提供 [`BitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.html) 的完全自定义实现：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setBitmapPool(new YourAppBitmapPoolImpl());
  }
}
```

#### 磁盘缓存

Glide 使用 [`DiskLruCacheWrapper`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.html) 作为默认的 [`磁盘缓存`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskCache.html) 。 [`DiskLruCacheWrapper`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.html) 是一个使用 LRU 算法的固定大小的磁盘缓存。默认磁盘大小为 [250 MB](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskCache.Factory.html#DEFAULT_DISK_CACHE_SIZE) ，位置是在应用的 [缓存文件夹](https://developer.android.com/reference/android/content/Context.html#getCacheDir()) 中的一个 [特定目录](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskCache.Factory.html#DEFAULT_DISK_CACHE_DIR) 。

假如应用程序展示的媒体内容是公开的（例如从无授权机制的网站或搜索引擎上加载），那么应用可以将这个缓存位置改到外部存储：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setDiskCache(new ExternalCacheDiskCacheFactory(context));
  }
}
```

无论使用内部或外部磁盘缓存，应用程序都可以改变磁盘缓存的大小：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    int diskCacheSizeBytes = 1024  1024  100;  100 MB
    builder.setDiskCache(new InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));
  }
}
```

应用程序还可以改变缓存文件夹在外存或内存上的名字：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    int diskCacheSizeBytes = 1024  1024  100;  100 MB
    builder.setDiskCache(
        new InternalCacheDiskCacheFactory(context, cacheFolderName, diskCacheSizeBytes));
  }
}
```

应用程序还可以自行选择 [`DiskCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskCache.html) 接口的实现，并提供自己的 [`DiskCache.Factory`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskCache.Factory.html) 来创建缓存。Glide 使用一个工厂接口来在后台线程中打开 [`磁盘缓存`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskCache.html) ，这样方便缓存做诸如检查路径存在性等的IO操作而不用触发 [严格模式](https://developer.android.com/reference/android/os/StrictMode.html) 。

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setDiskCache(new DiskCache.Factory() {
        @Override
        public DiskCache build() {
          return new YourAppCustomDiskCache();
        }
    });
  }
}
```

### 默认请求选项

虽然 [`请求选项`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html) 通常由每个请求单独指定，你也可以通过 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 应用一个 [`请求选项`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html) 的集合以作用于你应用中启动的每个加载：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setDefaultRequestOptions(
        new RequestOptions()
          .format(DecodeFormat.RGB_565)
          .disallowHardwareBitmaps());
  }
}
```

一旦你创建了新的请求，这些选项将通过 `GlideBuilder` 中的 `setDefaultRequestOptions` 被应用上。因此，任何单独请求里应用的选项将覆盖 `GlideBuilder` 里设置的冲突选项。

类似地，[`RequestManagers`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html) 允许你为这个特定的 [`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html) 启动的所有加载请求设置默认的 [`请求选项`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html)。 因为每个 `Activity` 和 `Fragment` 都拥有自己的 [`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html)，你可以使用 [`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html) 的 [`applyDefaultRequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html#applyDefaultRequestOptions-com.bumptech.glide.request.RequestOptions-) 方法来设置默认的 [`RequestOption`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html)，并仅作用于一个特定的 `Activity` 或 `Fragment`：

```
Glide.with(fragment)
  .applyDefaultRequestOptions(
      new RequestOptions()
          .format(DecodeFormat.RGB_565)
          .disallowHardwareBitmaps());
```

[`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html) 还有一个 [`setDefaultRequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html#setDefaultRequestOptions-com.bumptech.glide.request.RequestOptions-) 方法，可以完全替换掉之前设置的任意的默认 [`请求选项`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html)，无论它是通过 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的 [`GlideBuilder`] 还是 [`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html)。使用 [`setDefaultRequestOptions`]要小心，因为很容易意外覆盖掉你其他地方设置的重要默认选项。 通常 [`applyDefaultRequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/RequestManager.html#applyDefaultRequestOptions-com.bumptech.glide.request.RequestOptions-)更安全，使用起来更直观。

### 未捕获异常策略 (UncaughtThrowableStrategy)

在加载图片时假如发生了一个异常 (例如, OOM), Glide 将会使用一个 `GlideExecutor.UncaughtThrowableStrategy` 。

默认策略是将异常打印到设备的 LogCat 中。 这个策略从 Glide 4.2.0 起将可被定制。 你可以传入一个磁盘执行器和/或一个 resize 执行器：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    final UncaughtThrowableStrategy myUncaughtThrowableStrategy = new ...
    builder.setDiskCacheExecutor(newDiskCacheExecutor(myUncaughtThrowableStrategy));
    builder.setResizeExecutor(newSourceExecutor(myUncaughtThrowableStrategy));
  }
}
```

#### 日志级别

你可以使用 [`setLogLevel`](https://muyangmin.github.io/glide-docs-cn/javadocs/420/com/bumptech/glide/GlideBuilder.html#setLogLevel-int-) (结合 Android 的 [`Log`](https://developer.android.com/reference/android/util/Log.html) 定义的值) 来获取格式化日志的子集，包括请求失败时的日志行。通常来说 `Log.VERBOSE` 将使日志变得更冗杂，`Log.ERROR` 会让日志更趋向静默，详细可见 [javadoc](https://muyangmin.github.io/glide-docs-cn/javadocs/420/com/bumptech/glide/GlideBuilder.html#setLogLevel-int-) 。

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setLogLevel(Log.DEBUG);
  }
}
```

### 注册组件

应用程序和库都可以注册很多组件来扩展 Glide 的功能。可用的组件包括：

1. [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoaderFactory.html), 用于加载自定义的 Model(Url, Uri,任意的 POJO )和 Data(InputStreams, FileDescriptors)。
2. [`ResourceDecoder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/ResourceDecoder.html), 用于对新的 Resources(Drawables, Bitmaps)或新的 Data 类型(InputStreams, FileDescriptors)进行解码。
3. [`Encoder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Encoder.html), 用于向 Glide 的磁盘缓存写 Data (InputStreams, FileDesciptors)。
4. [`ResourceTranscoder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.html)，用于在不同的资源类型之间做转换，例如，从 BitmapResource 转换为 DrawableResource 。
5. [`ResourceEncoder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/ResourceEncoder.html)，用于向 Glide 的磁盘缓存写 Resources(BitmapResource, DrawableResource)。

组件通过 [`Registry`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/Registry.html) 类来注册。例如，添加一个 `ModelLoader` ，使其能从自定义的Model对象中创建一个 InputStream ：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void registerComponents(Context context, Registry registry) {
    registry.append(Photo.class, InputStream.class, new CustomModelLoader.Factory());
  }
}
```

在一个 `GlideModule` 里可以注册很多组件。[`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoaderFactory.html) 和 [`ResourceDecoder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/ResourceDecoder.html) 对于同样的参数类型还可以有多种实现。

### 剖析(Anatomy)一个请求

被注册组件的集合（包括默认被 Glide 注册的和在 Module 中被注册的），会被用于定义一个加载路径集合。每个加载路径都是从提供给 [`load`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#load-java.lang.Object-) 方法的数据模型到 [`as`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html#as-java.lang.Class-) 方法指定的资源类型的一个逐步演进的过程。一个加载路径（粗略地）由下列步骤组成:

1. 模型(Model) -> 数据(Data) (由`模型加载器(ModelLoader)`处理)
2. 数据(Data) -> 资源(Resource) (由`资源解析器(ResourceDecoder)`处理)
3. 资源(Resource) -> 转码后的资源(Transcoded Resource) (可选；由`资源转码器(ResourceTranscoder)`处理)

`编码器(Encoder)`可以在步骤2之前往Glide的磁盘缓存中写入数据。 `资源编码器(ResourceEncoder)`可以在步骤3之前网Glide的磁盘缓存写入资源。

当一个请求开始后，Glide将尝试所有从数据模型到请求的资源类型的可用路径。如果任何一个加载路径成功，这个请求就将成功。只有所有可用加载路径都失败时，这个请求才会失败。

### 排序组件

在 [`Registry`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/Registry.html) 类中定义了 `prepend()` , `append()` 和 `replace()` 方法，它们可以用于设置 Glide 尝试每个 `ModelLoader` 和 `ResourceDecoder` 之间的顺序。对组件进行排序允许你注册一些只处理特定树模型的子集的组件（即只处理特定类型的Uri，或仅仅特定类型的图像格式），并可以在后面追加一个捕获所有类型的组件以处理其他情况。

##### prepend()

假如你的 `ModelLoader` 或者 `ResourceDecoder` 在某个地方失败了，这时候你想将已有的数据交由 Glide 的默认行为来处理，可以使用 `prepend()`。 `prepend()` 将确保你的 `ModelLoader` 或 `ResourceDecoder` 先于之前注册的其他组件并被首先执行。如果你的 `ModelLoader` 或者 `ResourceDecoder` 从其 `handles()` 方法中返回了一个 `false` 或失败，所有其他的 `ModelLoader` 或 `ResourceDecoder` 将以它们被注册的顺序执行，一次一个，作为一种回退方案。

##### append()

要处理新的数据类型或提供一个到 Glide 默认行为的回退，使用 `append()`。`append()` 将确保你的 `ModelLoader` 或 `ResourceDecoder` 仅在 Glide 的默认组件被尝试后才会被调用。 如果你正在尝试处理 Glide 的默认组件能处理的某些子类型 (例如一些特定的 Uri 授权或子类型)，你可能需要使用 `prepend()` 来确保 Glide 的默认组件不会在你的定制组件之前加载。

##### replace()

要完全替换 Glide 的默认行为并确保它绝不运行，请使用 `replace()`。 `replace()` 将移除所有处理给定模型和数据类的 `ModelLoaders`，并添加你的 `ModelLoader` 来代替。 `replace()` 在使用库(例如 OkHttp 或 Volley)替换掉 Glide 的网络逻辑时尤其有用，这种时候你会希望确保仅 OkHttp 或 Volley 被调用。

#### 添加一个 ModelLoader

举个例子，添加一个 `ModelLoader`，它从一个新的自定义 Model 对象中建立一个 InputStream：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void registerComponents(Context context, Glide glide, Registry registry) {
    registry.append(Photo.class, InputStream.class, new CustomModelLoader.Factory());
  }
}
```

在这里，`append()`可以被安全地使用，因为 Photo.class 是一个你的应用定制的模型对象，所以你知道 Glide 的默认行为中并没有你需要替换的东西。

相反，如果要处理一种新的 [`BaseGlideUrlLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.html) 中的 String Url类型，你应该使用 `prepend()` 以使你的 `ModelLoader` 在 Glide 对 `Strings` 的默认 `ModelLoaders` 之前运行：

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void registerComponents(Context context, Glide glide, Registry registry) {
    registry.prepend(String.class, InputStream.class, new CustomUrlModelLoader.Factory());
  }
}
```

最后，如果要完全移除和替换 Glide 对某种特定类型的默认处理，例如一个网络库，你应该使用 `replace()`:

```
@GlideModule
public class YourAppGlideModule extends AppGlideModule {
  @Override
  public void registerComponents(Context context, Glide glide, Registry registry) {
    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());
  }
}
```

### 模块类和注解

Glide v4 依赖于两种类，[`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 与 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) ，以配置 Glide 单例。这两种类都允许用于注册额外的组件，例如 [`ModelLoaders`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoader.html) , [`ResourceDecoders`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/ResourceDecoder.html) 等。但只有 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 被允许配置应用特定的设置项，比如缓存实现和缓存大小。

#### AppGlideModule

如果应用希望实现 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的任意方法或使用集成库，则可以添加一个 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现。 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现是一个信号，它会让 Glide 的注解解析器生成一个单一的所有已发现的 [`LibraryGlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 的联合类。

对于一个特定的应用，只能存在一个 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现（超过一个会在编译时报错）。因此，程序库不能提供 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现。

#### @GlideModule

为了让 Glide 正确地发现 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 和 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 的实现类，它们的所有实现都必须使用 [`@GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideModule.html) 注解来标记。这个注解将允许 Glide 的 [注解解析器](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.html) 在编译时去发现所有的实现类。

#### 注解处理器

另外，为了发现 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 和 [`LibraryGlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html)，所有的库和应用还必须包含一个Glide的注解解析器的依赖。

### 冲突

应用程序可能依赖多个程序库，而它们每一个都可能包含一个或更多的 [`LibraryGlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 。在极端情况下，这些 [`LibraryGlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 可能定义了相互冲突的选项，或者包含了应用程序希望避免的行为。应用程序可以通过给他们的 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 添加一个 [`@Excludes`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/Excludes.html) 注解来解决这种冲突，或避免不需要的依赖。

例如，如果你依赖了一个库，它有一个 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 叫做`com.example.unwanted.GlideModule`，而你不想要它：

```
@Excludes(com.example.unwanted.GlideModule)
@GlideModule
public final class MyAppGlideModule extends AppGlideModule { }
```

你也可以排除多个模块：

```
@Excludes({com.example.unwanted.GlideModule, com.example.conflicing.GlideModule})
@GlideModule
public final class MyAppGlideModule extends AppGlideModule { }
```

[`@Excludes`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/Excludes.html) 注解不仅可用于排除 [`LibraryGlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 。如果你还在从 Glide v3 到新版本的迁移过程中，你还可以用它来排除旧的，废弃的 [`GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/GlideModule.html) 实现。

### 清单解析

为了维持对 Glide v3 的 [`GlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/GlideModule.html) 的向后兼容性，Glide 仍然会解析应用程序和所有被包含的库中的 `AndroidManifest.xml` 文件，并包含在这些清单中列出的旧 [`GlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/GlideModule.html) 模块类。

如果你已经迁移到 Glide v4 的 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 和 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) ，你可以完全禁用清单解析。这样可以改善 Glide 的初始启动时间，并避免尝试解析元数据时的一些潜在问题。要禁用清单解析，请在你的 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现中复写 [`isManifestParsingEnabled()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html#isManifestParsingEnabled--) 方法：

```
@GlideModule
public final class MyAppGlideModule extends AppGlideModule {
  @Override
  public boolean isManifestParsingEnabled() {
    return false;
  }
}
```



## 缓存 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/caching.html)

- [Glide里的缓存](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#glide里的缓存)
- [缓存键(Cache Keys)](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#缓存键cache-keys)
- 配置缓存
  - [磁盘缓存策略（Disk Cache Strategy）](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#磁盘缓存策略disk-cache-strategy)
  - [仅从缓存加载图片](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#仅从缓存加载图片)
  - [跳过缓存](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#跳过缓存)
  - [实现](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#实现)
- 缓存的刷新
  - [定制缓存刷新策略](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#定制缓存刷新策略)
- 资源管理
  - 内存缓存
    - [永久尺寸调整](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#永久尺寸调整)
    - [暂时尺寸调整](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#暂时尺寸调整)
  - 磁盘缓存
    - [永久尺寸修改](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#永久尺寸修改)
    - [清理磁盘缓存](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#清理磁盘缓存)

### Glide里的缓存

默认情况下，Glide 会在开始一个新的图片请求之前检查以下多级的缓存：

1. 活动资源 (Active Resources) - 现在是否有另一个 View 正在展示这张图片？
2. 内存缓存 (Memory cache) - 该图片是否最近被加载过并仍存在于内存中？
3. 资源类型（Resource） - 该图片是否之前曾被解码、转换并写入过磁盘缓存？
4. 数据来源 (Data) - 构建这个图片的资源是否之前曾被写入过文件缓存？

前两步检查图片是否在内存中，如果是则直接返回图片。后两步则检查图片是否在磁盘上，以便快速但异步地返回图片。

如果四个步骤都未能找到图片，则Glide会返回到原始资源以取回数据（原始文件，Uri, Url等）。

关于 Glide 缓存的默认大小与它们在磁盘上的位置的更多细节，或如何配置这些参数，请查看 [配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#disk-cache) 页面。

### 缓存键(Cache Keys)

在 Glide v4 里，所有缓存键都包含至少两个元素：

1. 请求加载的 model（File, Url, Url）。如果你使用自定义的 model, 它需要正确地实现 `hashCode()` 和 `equals()`
2. 一个可选的 [`签名`(Signature)](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#signature-com.bumptech.glide.load.Key-)

另外，步骤1-3(活动资源，内存缓存，资源磁盘缓存)的缓存键还包含一些其他数据，包括：

1. 宽度和高度
2. 可选的`变换（Transformation）`
3. 额外添加的任何 [`选项(Options)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Option.html)
4. 请求的数据类型 (Bitmap, GIF, 或其他)

活动资源和内存缓存使用的键还和磁盘资源缓存略有不同，以适应内存 [`选项(Options)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Option.html)，比如影响 Bitmap 配置的选项或其他解码时才会用到的参数。

为了生成磁盘缓存上的缓存键名称，以上的每个元素会被哈希化以创建一个单独的字符串键名，并在随后作为磁盘缓存上的文件名使用。

### 配置缓存

Glide 提供一系列的选项，以允许你选择加载请求与 Glide 缓存如何交互。

#### 磁盘缓存策略（Disk Cache Strategy）

[`DiskCacheStrategy`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/DiskCacheStrategy.html) 可被 [`diskCacheStrategy`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#diskCacheStrategy-com.bumptech.glide.load.engine.DiskCacheStrategy-) 方法应用到每一个单独的请求。 目前支持的策略允许你阻止加载过程使用或写入磁盘缓存，选择性地仅缓存无修改的原生数据，或仅缓存变换过的缩略图，或是兼而有之。

默认的策略叫做 [`AUTOMATIC`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/DiskCacheStrategy.html#AUTOMATIC) ，它会尝试对本地和远程图片使用最佳的策略。当你加载远程数据（比如，从URL下载）时，`AUTOMATIC` 策略仅会存储未被你的加载过程修改过(比如，变换，裁剪–译者注)的原始数据，因为下载远程数据相比调整磁盘上已经存在的数据要昂贵得多。对于本地数据，`AUTOMATIC` 策略则会仅存储变换过的缩略图，因为即使你需要再次生成另一个尺寸或类型的图片，取回原始数据也很容易。

指定 [`DiskCacheStrategy`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/DiskCacheStrategy.html) 非常容易:

```
Glide.with(fragment)
  .load(url)
  .diskCacheStrategy(DiskCacheStrategy.ALL)
  .into(imageView);
```

#### 仅从缓存加载图片

某些情形下，你可能希望只要图片不在缓存中则加载直接失败（*比如省流量模式？–译者注*）。如果要完成这个目标，你可以在单个请求的基础上使用 [`onlyRetrieveFromCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#onlyRetrieveFromCache-boolean-) 方法：

```
Glide.with(fragment)
  .load(url)
  .onlyRetrieveFromCache(true)
  .into(imageView);
```

如果图片在内存缓存或在磁盘缓存中，它会被展示出来。否则只要这个选项被设置为 true ，这次加载会视同失败。

#### 跳过缓存

如果你想确保一个特定的请求跳过磁盘和/或内存缓存（*比如，图片验证码 –译者注*），Glide 也提供了一些替代方案。

仅跳过内存缓存，请使用 [`skipMemoryCache()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#skipMemoryCache-boolean-) :

```
Glide.with(fragment)
  .load(url)
  .skipMemoryCache(true)
  .into(view);
```

仅跳过磁盘缓存，请使用 [`DiskCacheStrategy.NONE`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/DiskCacheStrategy.html#NONE) :

```
Glide.with(fragment)
  .load(url)
  .diskCacheStrategy(DiskCacheStrategy.NONE)
  .into(view);
```

这两个选项可以同时使用:

```
Glide.with(fragment)
  .load(url)
  .diskCacheStrategy(DiskCacheStrategy.NONE)
  .skipMemoryCache(true)
  .into(view);
```

虽然提供了这些办法让你跳过缓存，但你通常应该不会想这么做。从缓存中加载一个图片，要比拉取-解码-转换成一张新图片的完整流程快得多。

如果你只是想更新缓存中的某个条目，请继续阅读下面关于 [`invalidation`](https://muyangmin.github.io/glide-docs-cn/doc/caching.html#cache-invalidation) 一节的介绍。

#### 实现

如果内置的选项不满足你的需求，你也可以编写你自己的 [`DiskCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/cache/DiskCache.html) 实现。请查看 [配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#disk-cache) 页获得更多信息。

### 缓存的刷新

因为磁盘缓存使用的是哈希键，所以**并没有**一个比较好的方式来简单地删除某个特定url或文件路径对应的所有缓存文件。如果你只允许加载或缓存原始图片的话，问题可能会变得更简单，但因为Glide还会缓存缩略图和提供多种变换(`transformation`)，它们中的任何一个都会导致在缓存中创建一个新的文件，而要跟踪和删除一个图片的所有版本无疑是困难的。

在实践中，使缓存文件无效的最佳方式是在内容发生变化时（url，uri，文件路径等）更改你的标识符。

#### 定制缓存刷新策略

因为通常改变标识符比较困难或者根本不可能，所以Glide也提供了 [`签名`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#signature-com.bumptech.glide.load.Key-) API 来混合（你可以控制的）额外数据到你的缓存键中。签名(`signature`)适用于媒体内容，也适用于你可以自行维护的一些版本元数据。

- MediaStore 内容 - 对于媒体存储内容，你可以使用Glide的 [`MediaStoreSignature`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/signature/MediaStoreSignature.html) 类作为你的签名。`MediaStoreSignature` 允许你混入修改时间、MIME类型，以及item的方向到缓存键中。这三个属性能够可靠地捕获对图片的编辑和更新，这可以允许你缓存媒体存储的缩略图。
- 文件 - 你可以使用 [`ObjectKey`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/signature/ObjectKey.html) 来混入文件的修改日期。
- Url - 尽管最好的让 url 失效的办法是让 server 保证在内容变更时对URL做出改变，你仍然可以使用 [`ObjectKey`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/signature/ObjectKey.html) 来混入任意数据（比如版本号）。

将签名传入加载请求很简单：

```
Glide.with(yourFragment)
    .load(yourFileDataModel)
    .signature(new ObjectKey(yourVersionMetadata))
    .into(yourImageView);
```

媒体存储签名对于 MediaStore 数据来说也很直接：

```
Glide.with(fragment)
    .load(mediaStoreUri)
    .signature(new MediaStoreSignature(mimeType, dateModified, orientation))
    .into(view);
```

你还可以定义你自己的签名，只要实现 [`Key`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/Key.html) 接口就好。请确保正确地实现 `equals()`, `hashCode()` 和 `updateDiskCacheKey()` 方法:

```
public class IntegerVersionSignature implements Key {
    private int currentVersion;

    public IntegerVersionSignature(int currentVersion) {
         this.currentVersion = currentVersion;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof IntegerVersionSignature) {
            IntegerVersionSignature other = (IntegerVersionSignature) o;
            return currentVersion == other.currentVersion;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return currentVersion;
    }

    @Override
    public void updateDiskCacheKey(MessageDigest md) {
        messageDigest.update(ByteBuffer.allocate(Integer.SIZE).putInt(signature).array());
    }
}
```

请记住，为了避免降低性能，您将需要在后台批量加载任何版本元数据，以便在要加载图像时即已处于可用状态。

如果这些努力都无法奏效，您不能更改标识符，也不能跟踪任何合理的版本元数据的情况下，也可以使用 [`diskCacheStrategy()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#diskCacheStrategy-com.bumptech.glide.load.engine.DiskCacheStrategy-) 和 [`DiskCacheStrategy.NONE`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/DiskCacheStrategy.html#NONE) 来完全禁用磁盘缓存。

### 资源管理

Glide 的磁盘和内存缓存都是 LRU ，这意味着在达到使用限制或持续接近限制值之前，它们将占用持续增加的内存或磁盘空间。为了增加额外的灵活性，Glide 提供了一些额外的方式来让你可以管理你的应用使用的资源。

请记住，更大的内存缓存、位图池和磁盘缓存通常能提供更好的性能，或者至少在同等级别。如果你改变了缓存的大小， 你应该小心地测量一下你改动之前和之后的性能对比，以确保你的修改带来的性价比是可以接受的。

#### 内存缓存

默认情况下 Glide 的内存缓存和 [`BitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.html) 会响应 [`ComponentCallback2`](http://d.android.com/reference/android/content/ComponentCallbacks2.html?is-external=true) ，并根据 Android framework 提供的级别自动清理内容。 因此你通常不需要尝试动态监视或清理你的缓存或 [`BitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.html)。然而，如果必要的话，Glide 确实提供了几个手动选项。

##### 永久尺寸调整

要改变你应用中 Glide 的可用 RAM 大小，请查看 [配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#memory-cache)。

##### 暂时尺寸调整

要在你应用的特定部分暂时允许 Glide 使用更多或更少的内存，你可以使用 [`setMemoryCategory`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/Glide.html#setMemoryCategory-com.bumptech.glide.MemoryCategory-):

```
// This method must be called on the main thread.
Glide.get(context).clearMemory();
```

清理所有内存并非特别经济，并且应该尽可能避免，以避免出现抖动和增加加载时间。

#### 磁盘缓存

Glide 在运行时仅提供对磁盘缓存的有限控制，但是其大小和配置可以在 `AppGlideModule` 中改变。

##### 永久尺寸修改

要改变你应用中 Glide 可用的 sdcard 可用空间，请查看 [配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#memory-cache)。

##### 清理磁盘缓存

要尝试清理所有磁盘缓存条目，你可以使用 [`clearDiskCache`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/Glide.html#clearDiskCache--)。

```
new AsyncTask<Void, Void, Void> {
  @Override
  protected Void doInBackground(Void... params) {
    // This method must be called on a background thread.
    Glide.get(applicationContext).clearDiskCache();
    return null;
  }
}
```



## 资源重用 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/resourcereuse.html)

- [资源](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#资源)
- [好处](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#好处)
- [Dalvik](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#dalvik)
- Glide 如何追踪和重用资源
  - 引用计数
    - [增加引用计数](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#增加引用计数)
    - [减少引用计数](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#减少引用计数)
    - [释放资源](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#释放资源)
  - [池化 (Pooling)](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#池化-pooling)
- 常见错误
  - 资源重用错误的征兆
    - [Cannot draw a recycled Bitmap](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#cannot-draw-a-recycled-bitmap)
    - [Can’t call reconfigure() on a recycled bitmap](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#cant-call-reconfigure-on-a-recycled-bitmap)
    - [View 在图片之间闪烁或相同的图像在多个 View 中展示](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#view-在图片之间闪烁或相同的图像在多个-view-中展示)
  - 重用错误的原因
    - [尝试往相同的 Target 加载两个不同的资源](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#尝试往相同的-target-加载两个不同的资源)
    - [往Target中加载资源，清除或重用Target，并继续引用该资源](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#往target中加载资源清除或重用target并继续引用该资源)
    - [在 `Transformation` 中回收原始Bitmap](https://muyangmin.github.io/glide-docs-cn/doc/resourcereuse.html#在-transformationbitmap-中回收原始bitmap)

### 资源

Glide 中的资源包含很多东西，例如 `Bitmap`，`byte[]` 数组， `int[]` 数组，以及大量的 POJO 。无论什么时候，Glide 都会尝试重用这些资源，以限制你应用中的内存抖动数量。

### 好处

任何尺寸的对象的过多分配都会显著增加你应用中的垃圾回收 (GC)。虽然 Android 较新的 ART 运行时的 GC 惩罚比 Dalvik 运行时要低，但无论你使用什么设备，过多内存分配都会降低应用的性能。

### Dalvik

Dalvik 设备 (Lollipop 之前)在过多分配时将不得不面对特别大的代价，值得在这里讨论一下。

Dalvik 有两种基本的 GC 模式， GC_CONCURRENT 和 GC_FOR_ALLOC ，这两种你都可以在 logcat 中看到。

- GC_CONCURRENT 对于每次收集将阻塞主线程大约 5ms 。因为每个操作都比一帧(16ms)要小，GC_CONCURRENT 通常不会造成你的应用丢帧。
- GC_FOR_ALLOC 是一种 stop-the-world 收集，可能会阻塞主线程达到 125ms 以上。GC_FOR_ALLOC 几乎每次都会造成你的应用丢失多个帧，导致视觉卡顿，特别是在滑动的时候。

不幸的是，Dalvik 似乎甚至连适度的分配（例如一个 16kb 的缓冲区）都处理得不是很好。重复的中等分配，或即使单次大的分配（比如说一个 Bitmap ），将会导致 GC_FOR_ALLOC 。因此，你分配的内存越多，就会招来越多 stop-the-world 的 GC，而你的应用将有更多的丢帧。

通过复用中到大尺寸的资源， Glide 可以帮你尽可能地减少这种 GC，以保持应用的流畅。

## Glide 如何追踪和重用资源

Glide 采用较为宽容的办法来处理资源重用。Glide 会在它相信某个资源可以安全地复用时才这么做，但它并不要求调用者在每次请求之后都回收资源。除非某个调用者显式地表示它已经用完了某个资源（见下文），资源将不会被回收或重用。

### 引用计数

为决定某个资源是否正在被使用，以及什么时候可以安全地被重用，Glide 为每个资源保持了一个引用计数。

#### 增加引用计数

每次调用 [`into()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestBuilder.html#into-Y-) 来加载一个资源，这个资源的引用计数会被加一。如果相同的资源被加载到两个不同的 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html)，则在两个加载都完成后，它的引用计数将会为二。

#### 减少引用计数

引用计数仅在调用者通过以下方式表示它们用完资源后会减少：

1. 在加载资源的 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 或 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html) 上调用 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-) 。
2. 在这个[`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 或 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html) 上调用对另一个资源请求的 [`into`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestBuilder.html#into-Y-) 方法。

#### 释放资源

当引用计数到达 0 时，这个资源会被释放并被返回给 Glide 以重用。当资源被返回给 Glide 以重用以后，继续使用它是不安全的，因此以下行为是 **不安全的**：

1. 使用 `getImageDrawable` 来取回 `ImageView` 中加载的 `Bitmap` 或 `Drawable`，并使用某种方式展示它( `setImageDrawable`，动画，或 `TransitionDrawable` 或其他任何方式 )。
2. 使用 [`SimpleTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/SimpleTarget.html) 来将一个资源加载到 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true)，但没有实现 [`onLoadCleared()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#onLoadCleared-android.graphics.drawable.Drawable-) 方法并在其中将资源从 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 中移除。
3. 对 Glide 加载的任何 `Bitmap` 调用 [`recycle()`](https://developer.android.com/reference/android/graphics/Bitmap.html#recycle())。

在清理对应的 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 或 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html) 之后还保持对资源的引用是不安全的，因为这个资源可能已经被销毁，或被重用于展示一个不同的图片，这可能导致未定义行为，图形损坏，或甚至导致继续使用该资源的应用崩溃。例如，在被释放回 Glide 之后， `Bitmap` 可能会被存储在一个 `BitmapPool` 中，并在未来的某个时刻被用重用于保存一张新图片的字节数据，或者它们已经被调用了 [`recycle()`]。在这两种情况下继续引用这个 `Bitmap` 并期待它们保持原始图像都是不安全的。

### 池化 (Pooling)

尽管 Glide 的大部分回收逻辑主要针对 Bitmap，但所有的 [`Resource`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/Resource.html) 实现均可实现 [`recycle()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/Resource.html#recycle--) 方法并将它们包含的任意可重用的数据池化。 [`ResourceDecoder`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/ResourceDecoder.html) 可以返回开发者希望的任意 [`Resource`] API，因此开发者可以定制或提供额外的池化规则，只需要实现它们自己的 [`Resource`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/Resource.html) 和 [`ResourceDecoder`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/ResourceDecoder.html)。

特别地，对于 `Bitmap`，Glide 提供了一个 [`BitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.html) 接口，以允许 [`Resource`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/Resource.html) 获取和重用 [`Bitmap`] 对象。 Glide 的 [`BitmapPool`] 可以从任意的 `Context` 中使用 Glide 的单例获取到：

```
Glide.get(context).getBitmapPool();
```

类似地，希望为 `Bitmap` 池化施加更多控制的用户可以直接实现他们自己的 [`BitmapPool`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.html)，然后可以通过 `GlideModule` 的方式提供给 Glide。参见[配置页](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#bitmap-pool).

## 常见错误

然而，允许池化让保证用户不会误用资源或`Bitmap`变得很困难。 Glide 会在可能的地方尝试添加一些断言，但是因为我们并不持有底层的 `Bitmap`，我们无法保证调用者在告诉我们 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-) 或一个新请求之后，会立即停用这些资源。

### 资源重用错误的征兆

有多种迹象可能暗示 `Bitmap` 或其他在 Glide 中被池化的资源出了问题。我们列出了一些最常见的现象，但这不是一个完备的列表。

#### Cannot draw a recycled Bitmap

Glide 的 `BitmapPool` 是固定大小的。当 `Bitmap` 从中被踢出而没有被重用时，Glide 将会调用 [`recycle()`](https://developer.android.com/reference/android/graphics/Bitmap.html#recycle())。如果应用在向 Glide 指出可以安全地回收之后 “不经意间” 继续持有 `Bitmap`，则应用可能尝试绘制这个 `Bitmap`，进而在 `onDraw` 方法中造成崩溃。

一种可能的情况是，一个目标被用于两个`ImageView`，而其中一个在 `Bitmap` 被放到 `BitmapPool` 中后仍然试图访问被回收后的 `Bitmap`。基于以下因素，要复现这种复用错误可能很困难：1）Bitmap 何时被放入池中，2）Bitmap 何时被回收，3）何种尺寸的 `BitmapPool` 和内存缓存会导致 `Bitmap` 的回收。可以在你的 `GlideModule` 中加入下面的代码片段，以使这个问题更容易复现：

```
@Override
public void applyOptions(Context context, GlideBuilder builder) {
    int bitmapPoolSizeBytes = 1024 * 1024 * 0; // 0mb
    int memoryCacheSizeBytes = 1024 * 1024 * 0; // 0mb
    builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));
    builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));
}
```

上面的代码确保没有内存缓存，且 `BitmapPool` 的尺寸为0；因此 `Bitmap` 如果恰好没有被使用，它将立刻被回收。这是为了调试目的让它更快出现。

#### Can’t call reconfigure() on a recycled bitmap

资源将在它们不再被使用时被返回到 Glide 的 `BitmapPool` 中。这里的内部实现基于 `Request`(它控制着[`Resource`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/engine/Resource.html)) 的生命周期管理。如果在这些 Bitmap 上调用了 [`recycle()`](https://developer.android.com/reference/android/graphics/Bitmap.html#recycle())，但它们仍然在池中，就会使 Glide 无法重用它们而导致你的应用崩溃并抛出这个信息。这里的一个关键点是，这个崩溃很可能发生在未来的某个点，而不在这个违例代码的执行处！

#### View 在图片之间闪烁或相同的图像在多个 View 中展示

如果一个 `Bitmap` 被多次返回到 `BitmapPool` 中，或它已被返回到池中单仍然被一个 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 持有，另一个图片可能会被解码到这个 `Bitmap` 对象中。如果这种情况发生，就会使得 `Bitmap` 的内容会被替换为新的图片。 在这个过程中，`View` 可能仍然试图绘制这个 `Bitmap`，而这将导致原始的 `View` 展示一张新的图片。

### 重用错误的原因

一些常见的重用错误原因已被列在下面。就像上面的征兆一样，要列出全面的列表是很困难的，但是在尝试调试应用程序中的重用错误时，这些是您应该考虑的一些事情。

#### 尝试往相同的 Target 加载两个不同的资源

在 Glide 中没有安全的办法来加载多个资源到单一的 Target 中。用户可以使用 [`thumbnail()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-) API 来加载一系列资源到一个 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html)，但也仅仅在下一个 [`onResourceReady()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#onResourceReady-R-com.bumptech.glide.request.transition.Transition-) 调用之前才可以安全地引用早前的一个资源。

通常一个更好的答案是使用第二个 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 并将第二章图片加载到这第二个 View 上。 [`ViewSwitcher`](https://developer.android.com/reference/android/widget/ViewSwitcher.html) 可以很好地允许你在两个单独请求的不同图片之间做交叉淡入效果 (cross fade)。你可以仅添加一个 `ViewSwitcher` 在你的布局中，使用两个 `ImageView` 作为其子控件，然后使用两次 [`into(ImageView)`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestBuilder.html#into-android.widget.ImageView-)方法，每次一个子控件，来加载两张图片。

对于绝对要求将多个资源加载到相同 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 的用户，可以使用两个单独的 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html)。为确保每个加载都不会取消另一个，用户还需要避免使用 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/ViewTarget.html) 子类，或使用一个自定义的 [`ViewTarget`] 子类并复写(override)其 [`setRequest()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#setRequest-com.bumptech.glide.request.Request-) 和 [`getRequest()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#getRequest--) 以使得它们不使用 [`View`](http://d.android.com/reference/android/view/View.html?is-external=true) 的 tag 来存储 [`Request`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/Request.html)。这属于高级用法，一般不推荐。

#### 往Target中加载资源，清除或重用Target，并继续引用该资源

最简单的比较这个错误的办法是确保所有对资源的引用都在 [`onLoadCleared()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/request/target/Target.html#onLoadCleared-android.graphics.drawable.Drawable-) 调用时置空。通常，加载一个 `Bitmap` 然后对 `Target` 解引用，并且不要再次调用 [`into()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestBuilder.html#into-Y-) 或 [`clear()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/RequestManager.html#clear-com.bumptech.glide.request.target.Target-)，这样是安全的。然而，加载了一个 `Bitmap`，清除这个 `Target`，并在之后继续持有 `Bitmap` 引用是不安全的。类似地，加载资源到一个 `View` 上然后从 View 中获取这个资源 (通过 `getImageDrawable()` 或任何其他手段)，并在其他某个地方继续引用它，也是不安全的。

#### 在 `Transformation<Bitmap>` 中回收原始Bitmap

正如在 [`变换`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/Transformation.html) 的 JavaDoc 中所说，传入 [`transform()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.html#transform-com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool-android.graphics.Bitmap-int-int-) 的原始 `Bitmap` 将会自动被回收，只要这个 `Transformation` 返回的 `Bitmap` 和原始传入 [`transoform()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.html#transform-com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool-android.graphics.Bitmap-int-int-) 的不是同一个实例。这是和其他加载库很重要的一个不同，例如 Picasso。 [`BitmapTransformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.html) 提供了 Glide 的资源创建的模板，但它的回收是在内部完成的，所以不管是 `Transformation` 还是 `BitmapTransformation` 都不要回收传入的 `Bitmap` 或 `Resource`。

另外值得注意的是，任何定制的 `BitmapTransformation` 从 `BitmapPool` 中创建、但没有从 [`transform()`](https://muyangmin.github.io/glide-docs-cn/javadocs/431/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.html#transform-com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool-android.graphics.Bitmap-int-int-) 返回的中间 `Bitmap`，都会被返回到 `BitmapPool` 或被回收，但不会两种情况同时发生。你永远都不应该 [`recycle()`](https://developer.android.com/reference/android/graphics/Bitmap.html#recycle()) 从 Glide 中创建的 `Bitmap`。



## 调试 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/debugging.html)

- 本地日志(Local Logs)
  - [请求错误](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#请求错误)
  - [(非预期的)缓存未命中 (`Miss`)](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#非预期的缓存未命中-miss)
  - [请求监听器与定制日志](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#请求监听器与定制日志)
  - 图片和本地日志丢失
    - [启动请求失败(Failing to start the request)](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#启动请求失败failing-to-start-the-request)
    - 未指定尺寸（Missing Size）
      - [自定义Target(Custom Targets)](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#自定义targetcustom-targets)
      - [Views](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#views)
- Out of memory 错误
  - [过大的内存分配](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#过大的内存分配)
  - [内存泄露](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#内存泄露)
- 其他常见问题
  - [“You can’t start or clear loads in RequestListener or Target callbacks”](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#you-cant-start-or-clear-loads-in-requestlistener-or-target-callbacks)
  - [“cannot resolve symbol ‘GlideApp’”](https://muyangmin.github.io/glide-docs-cn/doc/debugging.html#cannot-resolve-symbol-glideapp)

### 本地日志(Local Logs)

如果你拥有设备的访问权限，你可以使用 `adb logcat` 或你的 IDE 查看一些日志。你可以使用 `adb shell setprop log.tag.<tag_name> <VERBOSE|DEBUG>` 操作为任何下面提到的标签(`tag`))开启日志。VERBOSE 级别的日志会显得更加冗余但包含更多有用的信息。根据你要查看的标签的不同，你可以把 VERBOSE 和 DEBUG 级别的信息都尝试一下，以决定哪个级别的信息是你最需要的。

#### 请求错误

最高级别和最容易理解的日志都通过 `Glide` 标签打印。Glide 标签将记录成功和失败的请求以及不同级别的详细信息，具体取决于日志级别。VERBOSE 会被用于记录成功的请求，DEBUG则会打印出详细的错误信息。

你也可以通过手动调用 [`setLogLevel(int)`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/GlideBuilder.html#setLogLevel-int-) 方法控制Glide标签的冗余度。`setLogLevel` 允许你–举个栗子–在开发构建(developer builds)时启用更加冗余的日志，而在发布(release builds)构建时则关闭它们。

#### (非预期的)缓存未命中 (`Miss`)

关于 Glide 缓存如何工作，请查阅 [缓存页](https://muyangmin.github.io/glide-docs-cn/doc/caching.html)。

`Engine` 标签会详细记录请求被填充的全过程，并包括用于存储相应资源的完整内存缓存键。如果你正在尝试调试“内存中明明有这个图片，为什么没在另一个地方用到”的问题，那么 `Engine` 标签可以让你直观地比较两者的缓存键的区别。

对于每一个开始了的请求，`Engine` 标签将会记录这个请求将会从哪个地方加载完成：缓存，活动资源，已存在的加载过程，或者一个新的加载过程。缓存：意味着这个资源暂时没有被用到，但是在内存缓存中可用。活动资源：表示这个资源正在被另一个 `Target` 使用，一般是在一个 `View` 中。已存在的加载过程：表示这个资源虽然现在在内存中不可用，但是另一个`Target`已经在早先发起了对同一个资源的请求，并且这个请求还在处理中。最后，新的加载过程表示这个资源既不在内存中，也没有被其他地方请求过，那么这将触发一次新的加载。

#### 请求监听器与定制日志

如果你想使用编程的办法跟踪成功和失败信息、跟踪应用中的整体缓存命中率，或增加对本地日志的控制，你可以使用 [`RequestListener`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestListener.html) 接口。 `RequestListener` 可以通过 [`RequestBuilder#listener()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#listener-com.bumptech.glide.request.RequestListener-) 方法来添加到单独的加载请求中。下面是一个使用示例：

```
Glide.with(fragment)
   .load(url)
   .listener(new RequestListener() {
       @Override
       boolean onLoadFailed(@Nullable GlideException e, Object model,
           Target<R> target, boolean isFirstResource) {
         // Log the GlideException here (locally or with a remote logging framework):
         Log.e(TAG, "Load failed", e);

         // You can also log the individual causes:
         for (Throwable t : e.getRootCauses()) {
           Log.e(TAG, "Caused by", t);
         }
         // Or, to log all root causes locally, you can use the built in helper method:
         e.logRootCauses(TAG);

         return false; // Allow calling onLoadFailed on the Target.
       }

       @Override
       boolean onResourceReady(R resource, Object model, Target<R> target,
           DataSource dataSource, boolean isFirstResource) {
         // Log successes here or use DataSource to keep track of cache hits and misses.

         return false; // Allow calling onResourceReady on the Target.
       }
    })
    .into(imageView);
```

请注意，每个 GlideException 都有多个 `Throwable` root cause。在 Glide 中可能有有任意多的方法使得 注册组件(`ModelLoader`, `ResourceDecoder`, `Encoder` 等)作用于从给定的模型（URL, File 等）加载给定的资源 (`Bitmap`, `GifDrawable` 等)。每个 `Throwable` root cause 描述了一个特定的 Glide 组件组合为什么失败。理解某个特定请求为何失败可能需要检查所有的 root cause。

然而，你也可能会发现某个单一的 root cause 比其他的要重要一些。例如你正在加载 URL 并试图找出特定的 HttpException (它意味着你的加载是由于一个网络错误而失败)，你可以遍历所有的 root cause 并使用 `instanceof` 来检查其类型：

```
for (Throwable t : e.getRootCauses()) {
  if (t instanceof HttpException) {
    Log.e(TAG, "Request failed due to HttpException!", t);
    break;
  }
}
```

当然你也可以使用类似的迭代过程和 `instanceof` 操作符来检查 Http 错误之外其他你关心的异常类型。

为减少对象分配起见，你可以为多个加载重用相同的`RequestListener`。

#### 图片和本地日志丢失

在某些情况下，你可能会发现某个图片永远不会加载出来，而且这个请求甚至还没有`Glide`标签和`Engine`标签的日志。这可能有以下一些原因。

##### 启动请求失败(Failing to start the request)

请检查你是否为你的请求调用了 [`into()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-android.widget.ImageView-) 或者 [`submit()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#submit-int-int-) 方法。很显然，如果你忘记了调用这两个方法，Glide 不会认为你已经要求开始加载。

##### 未指定尺寸（Missing Size）

如果你确信你调用了 [`into()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-android.widget.ImageView-) 、 [`submit()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#submit-int-int-) 之一，并且仍然没有看到日志，那么最可能的解释是，Glide 无法决定你即将加载资源的 `View` 或 `Target` 的尺寸。

###### 自定义Target(Custom Targets)

如果你正在使用一个自定义的 `Target` ，请确保你实现了 [`getSize`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/Target.html#getSize-com.bumptech.glide.request.target.SizeReadyCallback-) 方法并使用了非零的宽高来调用指定的回调方法，或者继承自一个已经为你实现了这个方法的 `Target` ，例如 [`ViewTarget`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/target/ViewTarget.html)。

###### Views

如果你只是在往一个 `View` 中加载资源，那么最大的可能是你的这个view要么还没有被布局(layout)过，要么被指定了零宽或高。View 的可见性被设置为 `View.GONE` 或它并没有被 attach ，都会导致 view 不会被 layout 。如果 View 和/或它们的父控件被以特定方式组合 `wrap_content` 和 `match_parent` 来作为宽高，则 view 可能会收到一个无效的或为 0 的宽高值。你可以试验一下，将你的 view 设定为非0的尺寸，或在请求时使用 [`override(int, int)` API](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html#override-int-int-) 来为 Glide 传入一个特定的尺寸。

### Out of memory 错误

几乎所有的 OOM 错误都是因为宿主应用出了问题，而不是 Glide 本身。 应用里两种常见的 OOM 错误分别是：

1. 过大的内存分配 (Excessively large allocations)
2. 内存泄露(Memory leaks, 被分配的内存没有被释放)

#### 过大的内存分配

如果在打开一个单独页面或加载一个单独图片导致了 OOM , 那么你的应用可能在加载一个不必要的大图。

使用 Bitmap 显示一张图片所需的内存数量为 宽(width) * 高(height) * 每像素字节数(bytes per pixel)。 每像素字节数取决于显示图片所使用的 `Bitmap.Config`，但通常对于 `ARGB_8888` 的位图来说，每个像素即为四个字节。因此，即使是一张普通的 1080P 图片也需要 8MB 内存。图片越大，所需要的内存就越多，因此一个 12M 像素的图片会要求相当庞大的 48MB 内存。

Glide 会将图片自动下采样 (downsample)，这是基于 `Target`，`ImageView` 或 `override()` 提供的尺寸。 如果你在 Glide 中看到了特别大的内存分配，通常意味着你的 `Target` 或 `override()` 提供的尺寸太大，或你使用了 `Target.SIZE_ORIGINAL` 而又恰好碰上了一个大图。

要解决这种过大的内存分配，请避免使用 `Target.SIZE_ORIGINAL` 并确保你的 `ImageView` 尺寸或你通过 `override()` 方法提供给 Glide 的尺寸是合理的。

#### 内存泄露

如果在你的应用中持续重复特定步骤会逐步增加你应用的内存使用并最终导致 OOM ，你可能有内存泄露。

[Android 官方文档](https://developer.android.com/studio/profile/investigate-ram.html) 中有很多关于追踪和调试内存使用的有用信息。为了调查内存泄露，你几乎肯定需要 [捕捉一个 heap dump](https://developer.android.com/studio/profile/investigate-ram.html#HeapDump) 并查看 Fragments, Activities 和以及其他不再被使用但却仍被持有的对象。

要修复内存泄露，你需要对已销毁的 `Fragment` 或 `Activity` 在生命周期的合适时机移除对它们的引用，以避免持有过多的对象。使用 heap dump 来帮助查找你应用中持有其他内存的方式并在找到后移除不必要的引用。通常你可以从列出对 Bitmap 对象（使用 [MAT](http://www.eclipse.org/mat/) 或其他内存分析器)的最短路径（不含弱引用）开始，然后寻找可疑的引用链。你还可以在你的内存分析器中搜索 `Activity` 和 `Fragment`，以确保每个 `Activity` 不超过一个实例，并且 `Fragment` 的实例数目也在期望范围内。

### 其他常见问题

#### “You can’t start or clear loads in RequestListener or Target callbacks”

如果你尝试在一个 `Target` 或 `RequestListener` 里的 `onResourceReady` 或 `onLoadFailed` 中开始一次新的加载，Glide 将会抛出一个异常。之所以抛出这个异常，是因为要处理和回收这种在通知过程中的 (notifying) 加载对我们来说是一个巨大的挑战。

好在这个问题很好解决。从 Glide 4.3.0 开始，你可以很轻松地使用 [`.error()`](http://bumptech.github.io/glide/javadocs/430/com/bumptech/glide/RequestBuilder.html#error-com.bumptech.glide.RequestBuilder-) 方法。这个方法接受一个任意的 [`RequestBuilder`](http://bumptech.github.io/glide/javadocs/430/com/bumptech/glide/RequestBuilder.html)，它会且只会在主请求失败时开始一个新的请求：

```
Glide.with(fragment)
  .load(url)
  .error(Glide.with(fragment)
     .load(fallbackUrl))
  .into(imageView);
```

对于 Glide 4.3.0 以前的版本，你也可以使用一个 Android [`Handler`](https://developer.android.com/reference/android/os/Handler.html) 来 post 一个 Runnable 给你的请求：

```
private final Handler handler = new Handler();
...

Glide.with(fragment)
  .load(url)
  .listener(new RequestListener<Drawable>() {
      ...

      @Override
      public boolean onLoadFailed(@Nullable GlideException e, Object model, 
          Target<Drawable> target, boolean isFirstResource) {
        handler.post(new Runnable() {
            @Override
            public void run() {
              Glide.with(fragment)
                .load(fallbackUrl)
                .into(imageView);
            }
        });
      }
  )
  .into(imageView);
```

#### “cannot resolve symbol ‘GlideApp’”

当使用 Generated API 时，你可能会遇到一些错误从而导致无法生成 Glide API。有时这些错误与你的 [设置](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html) 有关，但有时可能完全无关。
不相关的错误经常会被大量的非 root cause 的错误消息掩盖。有可能因错误过多而使得你无法在构建日志中找出 root cause。如果遇到这种情况而且你正在使用 Gradle，可以尝试添加以下代码以增加 Gradle 打印的错误信息数量：

```
allprojects {
  gradle.projectsEvaluated {
    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xmaxerrs" << "1000"
    }
  }
}
```

参见:

- https://github.com/bumptech/glide/issues/1945
- https://stackoverflow.com/questions/3115537/java-compilation-errors-limited-to-100/35707023#35707023



## 硬件位图 

- [什么是硬件位图（Hardware Bitmaps）？](https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html#什么是硬件位图hardware-bitmaps)
- [我们为什么应该使用硬件位图?](https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html#我们为什么应该使用硬件位图)
- [如何启用硬件位图?](https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html#如何启用硬件位图)
- [如何禁用硬件位图?](https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html#如何禁用硬件位图)
- [哪些情况不能使用硬件位图?](https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html#哪些情况不能使用硬件位图)
- [使用硬件位图有什么缺点?](https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html#使用硬件位图有什么缺点)

### 什么是硬件位图（Hardware Bitmaps）？

[`Bitmap.Config.HARDWARE`](https://developer.android.com/reference/android/graphics/Bitmap.Config.html#HARDWARE) 是一种 Android O 添加的新的位图格式。硬件位图仅在显存 (graphic memory) 里存储像素数据，并对图片仅在屏幕上绘制的场景做了优化。

### 我们为什么应该使用硬件位图?

因为硬件位图仅储存像素数据的一份副本。一般情况下，应用内存中有一份像素数据（即像素字节数组），而在显存中还有一份副本（在像素被上传到 GPU之后）。而硬件位图仅持有 GPU 中的副本，因此：

- 硬件位图仅需要**一半**于其他位图配置的内存；
- 硬件位图可避免绘制时上传纹理导致的内存抖动。

### 如何启用硬件位图?

目前，你可以在 Glide 请求中将默认的 [`DecodeFormat`](https://bumptech.github.io/glide/javadocs/460/com/bumptech/glide/load/DecodeFormat.html) 设置为 [`DecodeFormat.PREFER_ARGB_8888`](https://bumptech.github.io/glide/javadocs/460/com/bumptech/glide/load/DecodeFormat.html#PREFER_ARGB_8888)。要为应用中的所有请求都应用该操作，你需要在你的 `GlideModule` 中修改默认选项的 `DecodeFormat`，详见 [配置页](https://bumptech.github.io/glide/doc/configuration.html#default-request-options)。

未来 Glide 将默认加载硬件位图而不需要额外的启用配置，只保留禁用的选项。

### 如何禁用硬件位图?

如果你需要禁用硬件位图，你应当仅在以下的一些缓慢的或根本不可用 (broken) 的情况下才尝试去做。你可以使用 [`disallowHardwareConfig()`](https://bumptech.github.io/glide/javadocs/460/com/bumptech/glide/request/RequestOptions.html#disallowHardwareConfig--) 来为一个特定的请求禁用硬件位图：

```
Glide.with(fragment)
  .load(url)
  .disallowHardwareConfig()
  .into(imageView);
```

### 哪些情况不能使用硬件位图?

在显存中存储像素数据意味着这些数据不容易访问到，在某些情况下可能会发生异常。已知的情形列举如下：

- 在 Java 中读写像素数据，包括：

  - [Bitmap#getPixel](https://developer.android.com/reference/android/graphics/Bitmap.html#getPixel(int, int))
  - [Bitmap#getPixels](https://developer.android.com/reference/android/graphics/Bitmap.html#getPixels(int[], int, int, int, int, int, int))
  - [Bitmap#copyPixelsToBuffer](https://developer.android.com/reference/android/graphics/Bitmap.html#copyPixelsToBuffer(java.nio.Buffer))
  - [Bitmap#copyPixelsFromBuffer](https://developer.android.com/reference/android/graphics/Bitmap.html#copyPixelsFromBuffer(java.nio.Buffer))

- 在本地 (native) 代码中读写像素数据

- 使用软件画布 (software Canvas) 渲染硬件位图:

  ```
  Canvas canvas = new Canvas(normalBitmap)
  canvas.drawBitmap(hardwareBitmap, 0, 0, new Paint());
  ```

- 在绘制位图的 View 上使用软件层 (software layer type) （例如，绘制阴影）

  ```
  ImageView imageView = …
  imageView.setImageBitmap(hardwareBitmap);
  imageView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
  ```

- 打开过多的文件描述符 . 每个硬件位图会消耗一个文件描述符。这里存在一个每个进程的文件描述符限制 ( Android O 及更早版本一般为 1024，在某些 O-MR1 和更高的构建上是 32K)。Glide 将尝试限制分配的硬件位图以保持在这个限制以内，但如果你已经分配了大量的文件描述符，这可能是一个问题。

- 需要`ARGB_8888 Bitmaps` 作为前置条件

- 在代码中触发截屏操作，它会尝试使用 `Canvas` 来绘制视图层级。

  作为一个替代方案，在 Android O 以上版本你可以使用 [`PixelCopy`](https://developer.android.com/reference/android/view/PixelCopy.html).

- 共享元素过渡 (shared element transition)(OMR1已修复)

以下是一个示例 trace:

```
java.lang.IllegalStateException: Software rendering doesn't support hardware bitmaps
  at android.graphics.BaseCanvas.throwIfHwBitmapInSwMode(BaseCanvas.java:532)
  at android.graphics.BaseCanvas.throwIfCannotDraw(BaseCanvas.java:62)
  at android.graphics.BaseCanvas.drawBitmap(BaseCanvas.java:120)
  at android.graphics.Canvas.drawBitmap(Canvas.java:1434)
  at android.graphics.drawable.BitmapDrawable.draw(BitmapDrawable.java:529)
  at android.widget.ImageView.onDraw(ImageView.java:1367)
[snip]
  at android.view.View.draw(View.java:19089)
  at android.transition.TransitionUtils.createViewBitmap(TransitionUtils.java:168)
  at android.transition.TransitionUtils.copyViewImage(TransitionUtils.java:102)
  at android.transition.Visibility.onDisappear(Visibility.java:380)
  at android.transition.Visibility.createAnimator(Visibility.java:249)
  at android.transition.Transition.createAnimators(Transition.java:732)
  at android.transition.TransitionSet.createAnimators(TransitionSet.java:396)
[snip]
```

### 使用硬件位图有什么缺点?

在某些情况下为了避免打断用户，`Bitmap` 类将执行一次昂贵的显存复制。在某些使用这些方法的情况下，你应该根据使用这些缓慢方法的使用频率来考虑避免使用硬件位图配置。如果你确实要使用这些方法，系统将会打印一条信息： `“Warning attempt to read pixels from hardware bitmap, which is very slow operation”`，并触发一次 [`StrictMode#noteSlowCall`](https://developer.android.com/reference/android/os/StrictMode.html#noteSlowCall(java.lang.String))。

- [Bitmap#copy](https://developer.android.com/reference/android/graphics/Bitmap.html#copy(android.graphics.Bitmap.Config, boolean))
- [Bitmap#createBitmap*](https://developer.android.com/reference/android/graphics/Bitmap.html#createBitmap(android.graphics.Bitmap, int, int, int, int))
- [Bitmap#writeToParcel](https://developer.android.com/reference/android/graphics/Bitmap.html#writeToParcel(android.os.Parcel, int))
- [Bitmap#extractAlpha](https://developer.android.com/reference/android/graphics/Bitmap.html#extractAlpha())
- [Bitmap#sameAs](https://developer.android.com/reference/android/graphics/Bitmap.html#sameAs(android.graphics.Bitmap))



## 从v3迁移到v4 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/migrating.html)

- 选项(Options)
  - [RequestBuilder](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#requestbuilder)
  - [请求选项](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#请求选项)
  - [变换](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#变换)
  - [解码格式](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#解码格式)
  - 过渡选项
    - [交叉淡入 (Cross fade)](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#交叉淡入--cross-fade)
  - [Generated API](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#generated-api)
- 类型(Type)与目标(Target)
  - [选择资源类型](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#选择资源类型)
  - [Drawables](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#drawables)
  - Targets
    - [取消请求](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#取消请求)
- 配置
  - [应用程序](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#应用程序)
  - [程序库](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#程序库)
  - [清单解析](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#清单解析)
  - `using()`, ModelLoader, StreamModelLoader.
    - [ModelLoader](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#modelloader)
    - [`using()`](https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#using)

## 选项(Options)

Glide v4 中的一个比较大的改动是Glide库处理选项(`centerCrop()`, `placeholder()` 等)的方式。在 v3 版本中，选项由一系列复杂的异构建造者(multityped builders)单独处理。在新版本中，由一个单一类型的唯一一个建造者接管一系列选项对象。Glide 的[generated API](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html)进一步简化了这个操作：它会合并传入建造者的选项对象和任何已包含的集成库里的选项，以生成一个流畅的 API。

### RequestBuilder

对于这类方法：

```
listener()
thumbnail()
load()
into()
```

在 Glide v4 版本中，只存在一个 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 对应一个你正在试图加载的类型(`Bitmap`, `Drawable`, `GifDrawable` 等)。 `RequestBuilder` 可以直接访问对这个加载过程有影响的选项，包括你想加载的数据模型（url, uri等），可能存在的[`缩略图`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-)请求，以及任何的[`监听器`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#listener-com.bumptech.glide.request.RequestListener-)。`RequestBuilder`也是你使用 [`into()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-Y-) 或者 [`preload()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#preload-int-int-) 方法开始加载的地方：

```
RequestBuilder<Drawable> requestBuilder = Glide.with(fragment)
    .load(url);

requestBuilder
    .thumbnail(Glide.with(fragment)
        .load(thumbnailUrl))
    .listener(requestListener)
    .load(url)
    .into(imageView);
```

### 请求选项

对于这类方法：

```
centerCrop()
placeholder()
error()
priority()
diskCacheStrategy()
```

大部分选项被移动到了一个单独的称为 [`RequestOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html) 的对象中，

```
RequestOptions options = new RequestOptions()
    .centerCrop()
    .placeholder(R.drawable.placeholder)
    .error(R.drawable.error)
    .priority(Priority.HIGH);
```

`RequestOptions` 允许你一次指定一系列的选项，然后对多个加载重用它们：

```
RequestOptions myOptions = new RequestOptions()
    .fitCenter()
    .override(100, 100);

Glide.with(fragment)
    .load(url)
    .apply(myOptions)
    .into(drawableView);

Glide.with(fragment)
    .asBitmap()
    .apply(myOptions)
    .load(url)
    .into(bitmapView);
```

### 变换

Glide v4 里的 [`Transformations`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/Transformation.html) 现在会替换之前设置的任何变换。在 Glide v4 中，如果你想应用超过一个的 [`Transformation`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/Transformation.html)，你需要使用 [`transforms()`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html#transforms-com.bumptech.glide.load.Transformation...-) 方法：

```
Glide.with(fragment)
  .load(url)
  .transforms(new CenterCrop(), new RoundedCorners(20))
  .into(target);
```

### 解码格式

在 Glide v3， 默认的 [`DecodeFormat`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html) 是 [`DecodeFormat.PREFER_RGB_565`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html#PREFER_RGB_565)，它将使用 [`Bitmap.Config.RGB_565`]，除非图片包含或可能包含透明像素。对于给定的图片尺寸，`RGB_565` 只使用 [`Bitmap.Config.ARGB_8888`] 一半的内存，但对于特定的图片有明显的画质问题，包括条纹(banding)和着色(tinting)。为了避免`RGB_565`的画质问题，Glide 现在默认使用 `ARGB_8888`。结果是，图片质量变高了，但内存使用也增加了。

要将 Glide v4 默认的 [`DecodeFormat`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html) 改回 [`DecodeFormat.PREFER_RGB_565`](https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html#PREFER_RGB_565)，请在 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 中应用一个 `RequestOption`：

```
@GlideModule
public final class YourAppGlideModule extends GlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));
  }
}
```

关于使用 [`AppGlideModules`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的更多信息，请查阅 [配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html) 页面。请注意，为了让 Glide 发现你的 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 实现，你必须确保添加了对 Glide 的注解解析器的依赖。关于如何设置这个库的更多信息，请查看 [下载和设置](https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html)。

### 过渡选项

对于这类方法：

```
crossFade()
animate()
```

控制从占位符到图片和/或缩略图到全图的交叉淡入和其他类型变换的选项，被移动到了 [`TransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.html) 中。

要应用过渡（之前的动画），请使用下列选项中符合你请求的资源类型的一个：

- [`GenericTransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/GenericTransitionOptions.html)
- [`DrawableTransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.html)
- [`BitmapTransitionOptions`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.html)

如果你想移除任何默认的过渡，可以使用 `TransitionOptions.dontTransition()`][17](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/TransitionOptions.html#dontTransition--) 。

过渡动画通过 [`RequestBuilder`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html) 应用到请求上：

```
Glide.with(fragment)
    .load(url)
    .transition(withCrossFade(R.anim.fade_in, 300));
```

#### 交叉淡入 (Cross fade)

不同于 Glide v3，Glide v4 将**不会**默认应用交叉淡入或任何其他的过渡效果。每个请求必须手动应用过渡。

要为一个特定的加载应用一个交叉淡入变换效果，你可以使用：

```
import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;

Glide.with(fragment)
  .load(url)
  .transition(withCrossFade())
  .into(imageView);
```

或:

```
Glide.with(fragment)
  .load(url)
  .transition(
      new DrawableTransitionOptions
        .crossFade())
  .into(imageView);
```

### Generated API

为了让使用 Glide v4 更简单轻松，Glide 现在也提供了一套可以为应用定制化生成的 API。应用可以通过包含一个标记了 [`AppGlideModule`][[2](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 的实现来访问生成的 API。如果你不了解这是怎么工作的，可以查看 [Generated API](https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html) 。

你仍然可以使用生成的 `RequestOptions` 子类来应用相同的选项到多次加载中；但生成的 `RequestBuilder` 子类可能在多数情况下更为方便。

## 类型(Type)与目标(Target)

### 选择资源类型

Glide 允许你指定你想加载的资源类型。如果你指定了一个超类型，Glide 会尝试加载任何可用的子类型。比如，如果你请求的是 Drawable ，Glide 可能会加载一个 BitmapDrawable 或一个 GifDrawable 。而如果你请求的是一个 GifDrawable ，要么会加载出一个 GifDrawable，要么报错–只要图片不是 GIF 的话（即使它凑巧是一个完全有效的图片也是如此）。

默认请求的类型是 Drawable：

```
Glide.with(fragment).load(url)
```

如果要明确指定请求 Bitmap：

```
Glide.with(fragment).asBitmap()
```

如果要创建一个文件路径（本地图片的最佳选项）：

```
Glide.with(fragment).asFile()
```

如果要下载一个远程文件到缓存然后创建文件路径：

```
Glide.with(fragment).downloadOnly()
// or if you have the url already:
Glide.with(fragment).download(url);
```

### Drawables

Glide v3 版本中的 `GlideDrawable` 类已经被移除，支持标准的Android [`Drawable`](https://developer.android.com/reference/android/graphics/drawable/Drawable.html)。 `GlideBitmapDrawable` 也已经被删除，由 [`BitmapDrawable`](https://developer.android.com/reference/android/graphics/drawable/BitmapDrawable.html) 代替之。

如果你想知道某个 Drawable 是否是动画(animated)，可以检查它是否为 [`Animatable`](https://developer.android.com/reference/android/graphics/drawable/Animatable.html) 的实例。

```
boolean isAnimated = drawable instanceof Animatable;
```

### Targets

`onResourceReady` 方法的签名做了一些修改。例如，对于 `Drawables`:

```
onResourceReady(GlideDrawable drawable, GlideAnimation<? super GlideDrawable> anim) 
```

现在改为:

```
onResourceReady(Drawable drawable, Transition<? super Drawable> transition);
```

类似地, `onLoadFailed` 的签名也有一些变动：

```
onLoadFailed(Exception e, Drawable errorDrawable)
```

改为：

```
onLoadFailed(Drawable errorDrawable)
```

如果你想要获得更多导致加载失败的错误信息，你可以使用 [`RequestListener`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestListener.html) 。

#### 取消请求

`Glide.clear(Target)` 方法被移动到了 [`RequestManager`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html) 中:

```
Glide.with(fragment).clear(target)
```

使用 `RequestManager` 清除之前由它启动的加载过程，通常能提高性能，虽然这并不是强制要求的。Glide v4 会为每一个 Activity 和 Fragment 跟踪请求，所以你需要在合适的层级去清除请求。

## 配置

在 Glide v3 中，配置使用一个或多个 [`GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/360/com/bumptech/glide/module/GlideModule.html) 来完成。而在 Glide v4 中，配置改为使用一个类似但稍微复杂的系统来完成。

关于这个新系统的细节，可以查看[配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html)页面。

### 应用程序

在早期版本中使用了一个 [`GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/360/com/bumptech/glide/module/GlideModule.html) 的应用，可以将它转换为一个 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 。

在 Glide v3 中，你可能会有一个像这样的 `GlideModule` ：

```
public class GiphyGlideModule implements GlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setMemoryCache(new LruResourceCache(10 * 1024 * 1024));
  }

  @Override
  public void registerComponents(Context context, Registry registry) {
    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
  }
}
```

在 Glide v4 中，你需要将其转换成一个 `AppGlideModule` ，它看起来像这样：

```
@GlideModule
public class GiphyGlideModule extends AppGlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    builder.setMemoryCache(new LruResourceCache(10 * 1024 * 1024));
  }

  @Override
  public void registerComponents(Context context, Registry registry) {
    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());
  }
}
```

请注意，`@GlideModule` 注解不能省略。

如果你的应用拥有多个 `GlideModule`，你需要把其中一个转换成 `AppGlideModule`，剩下的转换成 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 。除非存在`AppGlideModule` ，否则程序不会发现 `LibraryGlideModule` ，因此您不能仅使用 `LibraryGlideModule` 。

### 程序库

拥有一个或多个 `GlideModule` 的程序库应该使用 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html) 。程序库不应该使用 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) ，因为它在一个应用里只能有一个。因此，如果你试图在程序库里使用它，将不仅会妨碍这个库的用户设置自己的选项，还会在多个程序库都这么做时造成冲突。

例如，v3 版本中 Volley 集成库的 `GlideModule` ：

```
public class VolleyGlideModule implements GlideModule {
  @Override
  public void applyOptions(Context context, GlideBuilder builder) {
    // Do nothing.
  }

  @Override
  public void registerComponents(Context context, Registry registry) {
    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
  }
}
```

在 v4 版本中可以转换成为一个 `LibraryGlideModule` ：

```
@GlideModule
public class VolleyLibraryGlideModule extends LibraryGlideModule {
  @Override
  public void registerComponents(Context context, Registry registry) {
    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));
  }
}
```

### 清单解析

为了简化迁移过程，尽管清单解析和旧的 [`GlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/360/com/bumptech/glide/module/GlideModule.html) 接口已被废弃，但它们在 v4 版本中仍被支持。`AppGlideModule`，`LibraryGlideModule`，与已废弃的 `GlideModule` 可以在一个应用中共存。

然而，为了避免检查元数据的性能天花板（以及相关的 bugs ），你可以在迁移完成后禁用掉清单解析，在你的 `AppGlideModule` 中复写一个方法：

```
@GlideModule
public class GiphyGlideModule extends AppGlideModule {
  @Override
  public boolean isManifestParsingEnabled() {
    return false;
  }

  ...
}
```

### `using()`, ModelLoader, StreamModelLoader.

#### ModelLoader

[`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoader.html) API 在 v4 版本中仍然存在，并且它的设计目标仍然和它在 v3 中一样，但有一些细节变化。

第一个细节，`ModelLoader` 的子类型如 `StreamModelLoader` ，现在已没有存在的必要，用户可以直接实现 `ModelLoader` 。例如，一个`StreamModelLoader<File>` 类现在可以通过 `ModelLoader<File, InputStream>` 的方式来实现和引用。

第二， `ModelLoader` 现在并不直接返回 `DataFetcher`，而是返回 [`LoadData`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoader.LoadData.html) 。[`LoadData`] 是一个非常简单的封装，包含一个磁盘缓存键和一个 `DataFetcher` 。

第三， `ModelLoaders` 有一个 `handles()` 方法，这使你可以为同一个类型参数注册超过一个的 ModelLoader 。

将一个 `ModelLoader` 从 v3 API转换到 v4 API ，通常是很简单直接的。如果你在你的 v3 `ModelLoader` 中只是简单滴返回一个 `DataFetcher` ：

```
public final class MyModelLoader implements StreamModelLoader<File> {

  @Override
  public DataFetcher<InputStream> getResourceFetcher(File model, int width, int height) {
    return new MyDataFetcher(model);
  }
}
```

那么你在 v4 替代类上需要做的仅仅只是封装一下这个 data fetcher ：

```
public final class MyModelLoader implements ModelLoader<File, InputStream> {

  @Override
  public LoadData<InputStream> buildLoadData(File model, int width, int height,
      Options options) {
    return new LoadData<>(model, new MyDataFetcher(model));
  }

  @Override
  public void handles(File model) {
    return true;
  }
}
```

请注意，除了 `DataFetcher` 之外，模型也被传递给 `LoadData` 作为缓存键的一部分。这个规则为某些特殊场景提供了更多对磁盘缓存键的控制。大部分实现可以直接将 model 传入 `LoadData` ，就像上面这样。

如果你仅仅是想为某些 model（而不是所有）使用你的 ModelLoader，你可以在你尝试加载 model 之前使用 `handles()` 方法来检查它。如果你从 `handles` 方法中返回了 `false` ，那么你的 `ModelLoader` 将不能加载指定的 model ，即使你的 `ModelLoader` 类型 (在这个例子里是 `File` 和 `InputStream`) 与之匹配。

举个例子，如果你在某个指定文件夹下写入了加密的图片，你可以使用 `handles` 方法来实现一个 `ModelLoader` 以从那个特定的文件夹下解密图片，但是并不用于加载其他文件夹下的 `File` ：

```
public final class MyModelLoader implements ModelLoader<File, InputStream> {
  private static final String ENCRYPTED_PATH = "/my/encrypted/folder";

  @Override
  public LoadData<InputStream> buildLoadData(File model, int width, int height,
      Options options) {
    return new LoadData<>(model, new MyDataFetcher(model));
  }

  @Override
  public void handles(File model) {
    return model.getAbsolutePath().startsWith(ENCRYPTED_PATH);
  }
}
```

#### `using()`

`using` API在 Glide v4 中被删除了，这是为了鼓励用户使用 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 一次性地 [注册](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#registering-components) 所有组件，避免对象重用(re-use, 原文如此 –译者注)。你无需每次加载图片时都创建一个新的 `ModelLoader` ；你应该在 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html) 中注册一次，然后交给 Glide 在每次加载时检查 model (即你传入 [`load()`](https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#load-java.lang.Object-) 方法的对象)来决定什么时候使用你注册的 ``ModelLoader` 。

为了确保你仅为特定的 model 使用你的 `ModelLoader` ，请像上面展示的那样实现 `handles` 方法：检查每个 model ，但仅在应当使用你的 `ModelLoader` 时才返回 true 。



## 编写定制的 ModelLoader 

原文链接：[点击查看](http://bumptech.github.io/glide/doc/resourcereuse.html)

- 编写一个 ModelLoader
  - [一个空实现](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#一个空实现)
  - [实现 `handles()`](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#实现-handles)
  - 实现 `buildLoadData`
    - [选择 `Key`](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#选择-key)
    - [选择 DataFetcher](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#选择-datafetcher)
- 编写 DataFetcher
  - [getDataClass](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#getdataclass)
  - [getDataSource](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#getdatasource)
  - [cancel](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#cancel)
  - [cleanup](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#cleanup)
  - [loadData](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#loaddata)
  - [完整的 DataFetcher](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#完整的-datafetcher)
- [完成 ModelLoader](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#完成-modelloader)
- 使用 Glide 注册我们的 ModelLoader
  - [添加 AppGlideModule](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#添加-appglidemodule)
  - [选择注册方法](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#选择注册方法)
  - [实现 ModelLoaderFactory](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#实现-modelloaderfactory)
  - [注册 ModelLoader](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#注册-modelloader)
- [完整示例](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#完整示例)
- [注意事项](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#注意事项)
- 高级使用场景
  - [委托(delegate)给另一个 ModelLoader](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#委托delegate给另一个-modelloader)
  - [在 ModelLoader 中处理自定义尺寸](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#在-modelloader-中处理自定义尺寸)
  - BaseGlideUrlLoader
    - [getUrl](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#geturl)
    - [getHeaders](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#getheaders)
- [鸣谢 (Credits)](https://muyangmin.github.io/glide-docs-cn/tut/custom-modelloader.html#鸣谢-credits)

虽然 Glide 内置了大部分常用模型（URL, Uri, 文件路径等）的支持，你还是可能偶尔会遇到一种 Glide 不支持的类型。你也可能会遇到需要定制或调整 Glide 默认行为的情况。你甚至可能会想要集成一种新的拉取图片的方法，或更换 Glide 目前支持的 [集成库](https://muyangmin.github.io/glide-docs-cn/int/about.html) 之外的网络库。

好在 Glide 是可扩展的。要添加对一种新的模型（Model）类型的支持，你需要按照以下步骤来执行：

1. 实现一个 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html)；
2. 实现一个 [`DataFetcher`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.html)，它可被你的 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html) 返回；
3. 将你的新 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/int/about.html) 注册到 Glide ，使用 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#applications) (或者，如果你正在改造的是一个程序库而不是应用，你需要使用 [`LibraryGlideModule`](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#libraries))。

所以让我们跟着这个步骤来，尝试实现一个定制的 `ModelLoader`，它接受 Base64 编码的图片字符串并使用 Glide 来解码。请注意如果你真要在你的应用中这么做的话，有一个更好的办法是在你的 `ModelLoader` 中取回 Base64 编码字符串，这样如果 Glide 之前缓存过你的图片，则可以避免加载图片到内存所需要耗费的 CPU 和内存。

但就我们这片文章的目的而言，我们希望提供一个简单的例子了来加载 Base64 图片，虽然它在真实世界里可能有些低效。

## 编写一个 ModelLoader

第一步是实现一个 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html) 接口。在开始之前，我们需要决定两件事情：

1. 我们要处理什么类型的模型 (Model)？
2. 对于那种模型我们应该产出什么类型的数据 (Data)？

在这个例子中，我们希望处理 Base64 编码的字符串，所以 `String` 可能是一个合适的 `Model` 类型。稍后我们将需要比单纯的随机字符串更具体的东西，不过现在 String 已经足够开始我们的实现了。

接下来我们需要决定我们应该从 String 中尝试产出什么类型的数据。默认情况下，Glide 提供了两种数据类型的图片解码器 (decoders)：

1. [`InputStream`](https://developer.android.com/reference/java/io/InputStream.html)
2. [`ByteBuffer`](https://developer.android.com/reference/java/nio/ByteBuffer.html)

Glide 也为解码视频提供了一个默认的 [`ParcelFileDescriptor`](https://developer.android.com/reference/android/os/ParcelFileDescriptor.html)支持。

因为我们是要解码图片，所以我们大概要使用 [`InputStream`](https://developer.android.com/reference/java/io/InputStream.html) 或 [`ByteBuffer`](https://developer.android.com/reference/java/nio/ByteBuffer.html)。因为我们已经在内存中拥有了所有的数据，而且我们将用于做实际解码的 [`Base64`](https://developer.android.com/reference/android/util/Base64.html) 的方法返回 `byte[]` ，所以 [`ByteBuffer`](https://developer.android.com/reference/java/nio/ByteBuffer.html) 可能是最好的选择。

### 一个空实现

现在我们已经知道了 `Model` 和 `Data` 的类型，我们可以创建一个类接受正确的参数类型并返回默认值：

```
package judds.github.com.base64modelloaderexample;

import android.support.annotation.Nullable;
import com.bumptech.glide.load.Options;
import com.bumptech.glide.load.model.ModelLoader;
import java.io.InputStream;
import java.nio.ByteBuffer;

/**
 * Loads an {@link InputStream} from a Base 64 encoded String.
 */
public final class Base64ModelLoader implements ModelLoader<String, ByteBuffer> {

  @Nullable
  @Override
  public LoadData<ByteBuffer> buildLoadData(String model, int width, int height, Options options) {
    return null;
  }

  @Override
  public boolean handles(String model) {
    return false;
  }
}
```

当然这个 `ModelLoader` 不会有什么作用，但这是一个开始。

### 实现 `handles()`

下一步是实现 [`handles()`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html#handles-Model-) 方法。正如我们之前提到过的，String 类型可能代表着多种模型类型，包括：

1. URL
2. Uri
3. File

`handles()` 方法允许 `ModelLoader` 高效地检查每个模型以避免加载不支持的类型。

为了简化我们的工作，这里让我们假定我们的 Base64 编码后的字符串将被实际使用 [data URI](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) 的方式传入。 handles 方法的目标是识别任何 Glide 传入的 String 参数，并为那些匹配 data uri 格式的串返回 `true`。

还好，data URI 格式很直接，因此我们可以只是检查 `data:` 前缀：

```
  @Override
  public boolean handles(String model) {
    return model.startsWith("data:");
  }
```

取决于我们对该实现所要求的鲁棒性程度，我们可能还希望检查嵌入的图片类型或数据格式，以避免我们加载错误的数据，例如一个 HTML 页面。但在这里为了简化起见我们将省略这些问题。

### 实现 `buildLoadData`

现在我们可以识别 data URI 了，下一步是提供一个对象，它将在给定模型、尺寸和选项的 `ByteBuffer` 未被缓存的时候做实际的解码工作。为此我们需要实现 [`buildLoadData`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html#buildLoadData-Model-int-int-com.bumptech.glide.load.Options-) 方法。

作为一个开始，我们的方法仅仅返回 `null`，这是完全合法的，虽然几乎没什么用：

```
  @Nullable
  @Override
  public LoadData<ByteBuffer> buildLoadData(String model, int width, int height, Options options) {
    return null;
  }
```

为了让这个方法更有用，让我们从返回一个新的 [`LoadData`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.LoadData.html) 开始。为此你需要做两件事情：

1. 一个 [`Key`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/Key.html) ，它将被用于磁盘缓存键的一部分 (模型的 `equals` 和 `hashCode()` 方法被用于内存缓存键)。
2. 一个 [`DataFetcher`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.html)，它可以从我们的特定模型中建立一个 `ByteBuffer`。

#### 选择 `Key`

在这个例子，用于磁盘缓存键的 [`Key`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/Key.html) 是很直接的，因为我们的模型类型是 `String` 。如果你有一个模型类型可以被使用 [`toString()`](https://developer.android.com/reference/java/lang/Object.html#toString()) 序列化，则你可以直接将这个模型传入一个新的 [`ObjectKey`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/signature/ObjectKey.html)：

```
Key diskCacheKey = new ObjectKey(model);
```

否则，你就要在这里实现 [`Key`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/Key.html) 接口，并确保 `equals`, `hashCode()`，以及 [`updateDiskCacheKey`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/Key.html#updateDiskCacheKey-java.security.MessageDigest-) 方法都被合理地填写并可以唯一地 (unique) 、一致 (consistent) 地标识你的特定模型。

因为我们现在只是与字符串字面值打交道，因此 [`ObjectKey`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/signature/ObjectKey.html) 就可以满足需求。

#### 选择 DataFetcher

因为我们正在添加一个新模型的支持，我们实际上将需要定制一个 DataFetcher 。在某些情况下，[`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html) 可能只是对 [`buildLoadData`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html#buildLoadData-Model-int-int-com.bumptech.glide.load.Options-) 传入的参数做一些简单的解析然后委托 (delegate) 给另一个 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html)，但这里我们可没这么幸运。

现在我们先传入一个 `null`（虽然它并不是一个合法的值），然后转到我们实际的 `DataFetcher` 实现中去：

```
  @Nullable
  @Override
  public LoadData<ByteBuffer> buildLoadData(String model, int width, int height, Options options) {
    return new LoadData<>(new ObjectKey(model), /*fetcher=*/ null);
  }
```

## 编写 DataFetcher

和 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html) 类似， [`DataFetcher`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.html) 接口是泛型的，它要求我们指定所期待的返回类型。好在我们已经决定了我们是想要加载 `ByteBuffer`，所以这里做决定并不困难。

因此，我们可以很快创建一个存根 (stub) 实现出来：

```
public class Base64DataFetcher implements DataFetcher<ByteBuffer> {

  @Override
  public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {}

  @Override
  public void cleanup() {}

  @Override
  public void cancel() {}

  @NonNull
  @Override
  public Class<ByteBuffer> getDataClass() {
    return null;
  }

  @NonNull
  @Override
  public DataSource getDataSource() {
    return null;
  }
}
```

虽然这里有很多个方法，但它们中的大部分都很容易实现。

#### getDataClass

`getDataClass` 没什么好讨论的，我们要加载 `ByteBuffer`：

```
  @NonNull
  @Override
  public Class<ByteBuffer> getDataClass() {
    return ByteBuffer.class;
  }
```

#### getDataSource

`getDataSource` 也基本不重要，但它有一些影响。Glide 对本地图片和远程图片的默认缓存策略是不同的。Glide 假定获取本地图片是简单廉价的，因此我们默认在它们被下采样和变换之后才缓存它们。相反，Glide 假定获取远程图片是困难而且昂贵的，因此我们将默认缓存获取到的原始数据。

对于 Base64 `String`，你的应用最好的选择可能取决于你如何获取到这些 `String`。如果它们是从一个本地数据库取得的，则 `DataSource.LOCAL` 最有意义。如果你每次通过 HTTP 取回它们，则 `DataSource.REMOTE` 比较合适。

现在让我们假设 `String` 是从本地获取的：

```
  @NonNull
  @Override
  public DataSource getDataSource() {
    return DataSource.LOCAL;
  }
```

#### cancel

对于可以取消的网络连接库或长时间加载，实现 `cancel()` 方法是一个好主意。这将帮助加速其他队列里的加载，并节约一些 CPU ，内存或其他资源。

在我们这个场景中， [`Base64`](https://developer.android.com/reference/android/util/Base64.html) 没有提供取消的 API ，所以我们可以把这里留空：

```
  @Override
  public void cancel() {
    // Intentionally empty.
  }
```

#### cleanup

`cleanup()` 方法很有意思。如果你正在加载一个 [`InputStream`](https://developer.android.com/reference/java/io/InputStream.html) 或打开任何 I/O 类的资源，你肯定要在 `cleanup()` 方法中关闭并清理这些 `InputStream` 或资源。

然而，在我们这个场景下我们仅仅只是要解码一个内存中的模型到内存中的数据。因此，这里没有东西需要清理，所以我们的方法也可以留空：

```
  @Override
  public void cleanup() {
    // Intentionally empty only because we're not opening an InputStream or another I/O resource!
  }
```

警告！请务必确认，如果你是打开 I/O 资源或一个 `InputStream`，你必须在这里关闭它们！我们仅仅是因为没有这么做所以这里才留了空 :)

#### loadData

现在最有趣的地方到了！`loadData()` 是 Glide 所期待你做那些繁重工作的地方。你可以安排一个异步任务，开启一个网络请求，从磁盘加载数据，或做任何你想做的事情。`loadData()` 只会被 Glide 的某个后台线程所调用。一个给定的 `DataFetcher` 在同一时间只会被一个后台线程使用，因此它不需要做到线程安全。然而，多个 `DataFetcher` 可能会被并行执行，因此 `DataFetcher` 所访问的任何共享资源应当是线程安全的。

`loadData()` 提供了两个参数：

1. [`Priority`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/Priority.html)，如果你正在使用网络库或其他队列系统，它可以用于含有优先级的请求。
2. [`DataCallback`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.DataCallback.html)，你需要使用你解码出来的数据来调用它，如果因为任何原因解码失败，你也可以使用错误消息来调用。

我们可以排队一个异步任务然后异步调用 [`DataCallback`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.DataCallback.html)，也可以在 `loadData()` 方法中做一些工作然后直接调用 [`DataCallback`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.DataCallback.html)。

在我们的例子中我们没有网络任务或队列需要调用，因此我们可以直接使用一行代码完成。

请注意，这里遗漏了一个重要的事情，我们居然没有对模型的引用！这是因为，每个 [`DataFetcher`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.html) 都是一个简单的闭包，可以用于从特定的模型中获取数据。因此，Glide 希望你在 [`DataFetcher`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/data/DataFetcher.html) 的构造器中传入一个模型：

```
  private final String model;

  Base64DataFetcher(String model) {
    this.model = model;
  }
```

事实证明，我们的 `loadData()` 方法实际上很简单。我们只需要将 Base64 部分从 data Uri 中解析出来即可：

```
  private String getBase64SectionOfModel() {
    // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs.
    int startOfBase64Section = model.indexOf(',');
    return model.substring(startOfBase64Section + 1);
  }
```

然后我们需要对着个 Base64 部分解码成 `byte[]`：

```
  byte[] data = Base64.decode(base64Section, Base64.DEFAULT);
```

并转换为一个 `ByteBuffer`：

```
  ByteBuffer byteBuffer = ByteBuffer.wrap(data);
```

然后我们只需要使用这个解码出来的 `ByteBuffer` 调用回调即可：

```
  callback.onDataReady(byteBuffer);
```

完成这一切之后，我们就有了一个 `loadData()` 的完整实现：

```
  @Override
  public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {
    String base64Section = getBase64SectionOfModel();
    byte[] data = Base64.decode(base64Section, Base64.DEFAULT);
    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
    callback.onDataReady(byteBuffer);
  }

  private String getBase64SectionOfModel() {
    // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs.
    int startOfBase64Section = model.indexOf(',');
    return model.substring(startOfBase64Section + 1);
  }
```

#### 完整的 DataFetcher

现在让我们把在 `DataFetcher` 中实现的方法放到一起，看看完整的代码：

```
package judds.github.com.base64modelloaderexample;

import android.support.annotation.NonNull;
import android.util.Base64;
import com.bumptech.glide.Priority;
import com.bumptech.glide.load.DataSource;
import com.bumptech.glide.load.data.DataFetcher;
import java.nio.ByteBuffer;

public class Base64DataFetcher implements DataFetcher<ByteBuffer> {

  private final String model;

  Base64DataFetcher(String model) {
    this.model = model;
  }

  @Override
  public void loadData(Priority priority, DataCallback<? super ByteBuffer> callback) {
    String base64Section = getBase64SectionOfModel();
    byte[] data = Base64.decode(base64Section, Base64.DEFAULT);
    ByteBuffer byteBuffer = ByteBuffer.wrap(data);
    callback.onDataReady(byteBuffer);
  }

  private String getBase64SectionOfModel() {
    // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs.
    int startOfBase64Section = model.indexOf(',');
    return model.substring(startOfBase64Section + 1);
  }

  @Override
  public void cleanup() {
    // Intentionally empty only because we're not opening an InputStream or another I/O resource!
  }

  @Override
  public void cancel() {
    // Intentionally empty.
  }

  @NonNull
  @Override
  public Class<ByteBuffer> getDataClass() {
    return ByteBuffer.class;
  }

  @NonNull
  @Override
  public DataSource getDataSource() {
    return DataSource.LOCAL;
  }
}
```

## 完成 ModelLoader

回想我们刚刚在写 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html) 时，我们的 [`buildLoadData`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html#buildLoadData-Model-int-int-com.bumptech.glide.load.Options-) 方法有一些不完整，我们返回了一个 `null`，而不是一个合适的 `DataFetcher`：

```
  @Nullable
  @Override
  public LoadData<ByteBuffer> buildLoadData(String model, int width, int height, Options options) {
    return new LoadData<>(new ObjectKey(model), /*fetcher=*/ null);
  }
```

现在我们已经有了一个 `DataFetcher` 实现，我们可以将它填进去：

```
  @Override
  public LoadData<ByteBuffer> buildLoadData(String model, int width, int height, Options options) {
    return new LoadData<>(new ObjectKey(model), new Base64DataFetcher(model));
  }
```

我们可以删除 `@Nullable` 因为实际上在我们的实现中永远不会返回 `null`。 如果我们委托给另一个封装的 `ModelLoader`，我们需要检查那个 `ModelLoader` 的返回值并确保它返回 `null` 时我们也返回 `null`。实际上，在某些情形下我们可能会在尝试解析数据时发现我们并不能加载它，这时候我们也可以返回 `null`。

## 使用 Glide 注册我们的 ModelLoader

我们已经接近完工，不过还差最后一步。我们的 `ModelLoader` 实现已经完成了，但完全没有使用它。要完成我们的项目，我们需要告诉 Glide 以使得 Glide 知道需要使用它。

### 添加 AppGlideModule

为此，我们将按照 [配置](https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#applications) 里的步骤为我们的应用添加一个 [`AppGlideModule`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/module/AppGlideModule.html)，如果你还没有做的话：

```
package judds.github.com.base64modelloaderexample;

import com.bumptech.glide.annotation.GlideModule;
import com.bumptech.glide.module.AppGlideModule;

@GlideModule
public class MyAppGlideModule extends AppGlideModule { }
```

不要忘了也给你的 build.gradle 文件里添加对 Glide 的注解解析器的依赖：

```
annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'
```

接下来我们要获取 Glide 的 [`Registry`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/Registry.html)，因此我们将在我们的 `AppGlideModule` 中实现 [`registerComponents`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/module/LibraryGlideModule.html#registerComponents-android.content.Context-com.bumptech.glide.Glide-com.bumptech.glide.Registry-) 方法：

```
package judds.github.com.base64modelloaderexample;

import com.bumptech.glide.annotation.GlideModule;
import com.bumptech.glide.module.AppGlideModule;

@GlideModule
public class MyAppGlideModule extends AppGlideModule { 
  @Override
  public void registerComponents(Context context, Glide glide, Registry registry) {
    // TODO: implement this.
  }
}
```

### 选择注册方法

为了告知 Glide 我们的 `ModelLoader`，我们需要使用 `ModelLoader` 的方法之一将其添加到 [`Registry`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/Registry.html)。

`ModelLoader` 是按照它们注册的顺序存储在一个列表中的。当你开启一个新的加载后，Glide 将查找所有已注册的 `ModelLoader`，使用你的提供的模型类型按照它们的注册顺序逐个尝试。

因此，如果你正在添加一种新的 Model 类型支持，你通常想要 [`prepend`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/Registry.html#prepend-java.lang.Class-java.lang.Class-com.bumptech.glide.load.model.ModelLoaderFactory-) 你的 `ModelLoader`，这样 Glide 将在默认的 `ModelLoader` 之前尝试它。在我们的例子中，我们确实是在做这件事，添加一种新模型类型，因此我们使用 [`prepend`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/Registry.html#prepend-java.lang.Class-java.lang.Class-com.bumptech.glide.load.model.ModelLoaderFactory-)。

不过，这里还有一点小麻烦。[`prepend`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/Registry.html#prepend-java.lang.Class-java.lang.Class-com.bumptech.glide.load.model.ModelLoaderFactory-) 要求一个 [`ModelLoaderFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoaderFactory.html)，而不是一个 [`ModelLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html)。这允许你委托给其他的 `ModelLoader`，甚至它们可以被动态注册，但这也使得你在定义新的加载器时需要再多实现一个接口。

### 实现 ModelLoaderFactory

还好，[`ModelLoaderFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoaderFactory.html) 接口非常简单，所以我们很容易添加它：

```
package judds.github.com.base64modelloaderexample;

import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.model.ModelLoaderFactory;
import com.bumptech.glide.load.model.MultiModelLoaderFactory;
import java.nio.ByteBuffer;

public class Base64ModelLoaderFactory implements ModelLoaderFactory<String, ByteBuffer> {

  @Override
  public ModelLoader<String, ByteBuffer> build(MultiModelLoaderFactory unused) {
    return new Base64ModelLoader();
  }

  @Override
  public void teardown() { 
    // Do nothing.
  }
}
```

[`ModelLoaderFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoaderFactory.html) 的类型需要完全匹配我们在 `ModelLoader` 中使用的类型。

### 注册 ModelLoader

最后，我们只需要更新我们的 `AppGlideModule` 来使用我们的新 Factory :

```
@GlideModule
public class MyAppGlideModule extends AppGlideModule {
  @Override
  public void registerComponents(Context context, Glide glide, Registry registry) {
    registry.prepend(String.class, ByteBuffer.class, new Base64ModelLoaderFactory());
  }
}
```

这就行了！

现在我们可以使用任何带有 Base64 编码图片的 Data URI 并让 Glide 来加载它：

```
String dataUri = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYA..."
Glide.with(fragment)
  .load(dataUri)
  .into(imageView);
```

## 完整示例

这里有一个完整的示例项目，它使用了我们写的这些代码： [https://github.com/sjudd/Base64ModelLoaderExample](https://github.com/sjudd/Base64ModelLoaderExample/commit/ae004dc4b325ee39814f197cc196d7371fbccdf1)

在示例中的提交信息是按照我们编写的顺序来的：

1. [An empty project with a blank Activity](https://github.com/sjudd/Base64ModelLoaderExample/commit/d9ee7eb9285ed1a7279cc085b3abd0f1369f92dd)
2. [A ModelLoader that just implements handles](https://github.com/sjudd/Base64ModelLoaderExample/commit/83ae04155b79056487299f65f70e172c11ff53ae)
3. [A data fetcher implementation](https://github.com/sjudd/Base64ModelLoaderExample/commit/70a4facda7504c375ca9150ea2a6789077bbd7e1)
4. [A ModelLoader with a complete buildLoadData implementation](https://github.com/sjudd/Base64ModelLoaderExample/commit/8c641cb1be3afbf1ff0d8bcba7b37b1778f06dc4)
5. [An AppGlideModule and registered ModelLoader](https://github.com/sjudd/Base64ModelLoaderExample/commit/d4e1cd9dcc011bb6d2910301c5783290fbe3bb89)
6. [An example data Uri loaded into a View](https://github.com/sjudd/Base64ModelLoaderExample/commit/ae004dc4b325ee39814f197cc196d7371fbccdf1)

## 注意事项

实际上，Glide 已经支持了 Data URI，所以如果你只是想使用 Data URI 加载 Base64 字符串的话并不需要做什么。这份代码只是作为示例目的。

如果你确实想实现 Data uri 的支持，你可能想在 `handles()` 方法或 `DataFetcher` 中做更多的错误检查，来处理索引超出 URI 边界时被截断的字符串。

## 高级使用场景

我们上面的示例并不适合某些高级使用场景。我们将在这里单独讨论。

### 委托(delegate)给另一个 ModelLoader

我们之前提到过，但没有详细讨论的一个事情是，Glide 允许你在一个定制的 ModelLoader 中委托给一个已存在的 ModelLoader 。拥有一个 Glide 不理解的自定义模型类型并不罕见，但是能够相对容易地从自定义类型中提取一个 Glide 能够理解的模型类型，如 URL ，Uri 或文件路径。

使用委托技术，你可以支持你的定制模型，而将 Glide 能理解和委托的模型提取出来。

举个例子，在 Glide 的[Giphy 示例应用](https://muyangmin.github.io/glide-docs-cn/ref/samples.html#giphy) 中，我们从 Giphy 的 API 中获取了一个 JSON 对象，包含一个 URL 集合：

```
/**
 * A POJO mirroring an individual GIF image returned from Giphy's API.
 */
public static final class GifResult {
  public String id;
  GifUrlSet images;

  @Override
  public String toString() {
    return "GifResult{" + "id='" + id + '\'' + ", images=" + images
        + '}';
  }
}
```

尽管我们可以在我们的 View 逻辑中提取出 URL，就像这样：

```
Glide.with(fragment)
  .load(gifResult.images.fixed_width)
  .into(imageView);
```

但如果我们可以直接传入 `GifResult`，这个代码将更简洁：

```
Glide.with(fragment)
  .load(gifResult)
  .into(imageView);
```

如果我们必须重写所有的 URL 逻辑来才能完成这样的想法，这显然不值得。然而我们可以委托，因此最后我们得到了一个很简单的 `ModelLoader` 实现：

```
public final class GiphyModelLoader extends BaseGlideUrlLoader<Api.GifResult> {
  private final ModelLoader<GlideUrl, InputStream> urlLoader;

  private GiphyModelLoader(ModelLoader<GlideUrl, InputStream> urlLoader) {
    this.urlLoader = urlLoader;
  }

  @Override
  public boolean handles(@NonNull Api.GifResult model) {
    return true;
  }

  @Override
  public LoadData<InputStream> buildLoadData(
      @NonNull Api.GifResult model, int width, int height, @NonNull Options options) {
    return urlLoader.buildLoadData(model.images.fixed_width, width, height, options);
  }
}
```

`ModelLoader` 的构造器所要求的 `ModelLoader<GlideUrl, InputStream>` 通过 `ModelLoaderFactory` 提供，对于一个特定的模型和数据类型（在这个场景中是 `GlideUrl` 和 `InputSteam`），它可以查找当前注册的 `ModelLoader`：

```
/**
 * The default factory for {@link com.bumptech.glide.samples.giphy.GiphyModelLoader}s.
 */
public static final class Factory implements ModelLoaderFactory<GifResult, InputStream> {
  @Override
  public ModelLoader<Api.GifResult, InputStream> build(MultiModelLoaderFactory multiFactory) {
    return new GiphyModelLoader(multiFactory.build(GlideUrl.class, InputStream.class));
  }

  @Override public void teardown() {}
}
```

Glide 的 `ModelLoader` 采用懒惰构建，且会在新注册了 `ModelLoader` 之后将旧的剔除 (tear down)，因此当你使用这种委托模式时，你永远不会用到一个旧的 `ModelLoader`。因此，我们的 `GiphyModelLoader` 是与我们实际用于加载 URL 的网络库完全解耦的。

[`MultiModelLoaderFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/MultiModelLoaderFactory.html) 可用于获取任何已注册的 `ModelLoader`。如果同一个给定的类型有多个 `ModelLoader`注册，则 `MultiModelLoaderFactory` 将返回一个被包装 (wrap) 过的 `ModelLoader` ，它将依次尝试每个 [`handles()`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html#handles-Model-) 方法返回 `true` 的 `ModelLoader`，直到其中一个成功为止。

### 在 ModelLoader 中处理自定义尺寸

即使用了委托，上面这个 Giphy 的例子好像还是为了一个更轻便好看的 API 做了不少工作。不过，拥有你自己的 `ModelLoader` 还有一些额外的好处，特别是像 Giphy 这样你可以从多个 URL 中选择的 API 。

尽管我们之前在 Base64 `ModelLoader` 中实现了 [`buildLoadData()`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/ModelLoader.html#buildLoadData-Model-int-int-com.bumptech.glide.load.Options-)，但我们从没有讨论过这里提供的除 model 之外的参数。`buildLoadData()` 还传入了一个宽度和高度，可以用于选择最合适尺寸的图片，如此可通过只拉取、缓存和解码最小的必要图片来节省带宽、内存、CPU，以及磁盘空间等。

`buildLoadData()` 传入的宽度和高度可能是被 [`Target`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/request/target/Target.html) 提供的，或如果你指定的话则为请求 [`override()`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/request/RequestOptions.html#override-int-int-) 的尺寸。如果你正在往 `ImageView` 中加载数据，则这个宽度和高度即为 `ImageView` 的宽高（同样，除非你使用了 `override()`）。如果你使用了 `Target.SIZE_ORIGINAL`，那么宽高将为常量值 `Target.SIZE_ORIGINAL`。

实际的 [`GiphyModelLoader`](https://github.com/bumptech/glide/blob/b4b45791cca6b72345a540dcaa71a358f5706276/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java#L31) 有一个简单的示例，使用 `buildLoadData()` 提供的尺寸来选取最佳的 URL ：

```
@Override
protected String getUrl(Api.GifResult model, int width, int height, Options options) {
  Api.GifImage fixedHeight = model.images.fixed_height;
  int fixedHeightDifference = getDifference(fixedHeight, width, height);
  Api.GifImage fixedWidth = model.images.fixed_width;
  int fixedWidthDifference = getDifference(fixedWidth, width, height);
  if (fixedHeightDifference < fixedWidthDifference && !TextUtils.isEmpty(fixedHeight.url)) {
    return fixedHeight.url;
  } else if (!TextUtils.isEmpty(fixedWidth.url)) {
    return fixedWidth.url;
  } else if (!TextUtils.isEmpty(model.images.original.url)) {
    return model.images.original.url;
  } else {
    return null;
  }
}
```

在 Glide 的 [Flickr 示例应用](https://muyangmin.github.io/glide-docs-cn/ref/samples.html#flickr)，我们也看到了一个类似的模式，尽管它使用了多种缩略尺寸在一定程度上增强了鲁棒性。

如果你能访问的 API 允许你指定特定尺寸或提供了大量的缩略图尺寸变种，那么使用一个定制的 `ModelLoader` 可以显著提升你的应用性能。

### BaseGlideUrlLoader

为了节省在编写定制 `ModelLoader` 时仅仅委托给默认网络库的一些模板代码，Glide 包含了一个 [`BaseGlideUrlLoader`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.html) 抽象类。我们之前的一些示例，包括 [`GiphyModelLoader`](https://github.com/bumptech/glide/blob/b4b45791cca6b72345a540dcaa71a358f5706276/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java#L31) 和 [`FlickrModelLoader`](https://github.com/bumptech/glide/blob/b4b45791cca6b72345a540dcaa71a358f5706276/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java#L21) 都使用了这个类。

`BaseGlideUrlLoader` 提供了一些基础的缓存，以最小化 `String` 分配，以及两个简便方法：

1. [`getUrl()`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.html#getUrl-Model-int-int-com.bumptech.glide.load.Options-)，它为一个给定的模型返回一个 `String` URL；
2. [`getHeaders`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.html#getHeaders-Model-int-int-com.bumptech.glide.load.Options-)，可选实现，用于为一个给定的模型和尺寸返回一个 HTTP [`Headers`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/Headers.html)，如果你需要添加一个授权或其他类型的 header 的话。

#### getUrl

如果你阅读了之前关于处理自定义尺寸的章节，你可能已经注意到我们在 [`GiphyModelLoader`](https://github.com/bumptech/glide/blob/b4b45791cca6b72345a540dcaa71a358f5706276/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java#L31) 中引用的方法并非 [`buildLoadData()`]。它实际上仅仅是 `getUrl` 这个简便方法：

```
@Override
protected String getUrl(Api.GifResult model, int width, int height, Options options) {
  Api.GifImage fixedHeight = model.images.fixed_height;
  int fixedHeightDifference = getDifference(fixedHeight, width, height);
  Api.GifImage fixedWidth = model.images.fixed_width;
  int fixedWidthDifference = getDifference(fixedWidth, width, height);
  if (fixedHeightDifference < fixedWidthDifference && !TextUtils.isEmpty(fixedHeight.url)) {
    return fixedHeight.url;
  } else if (!TextUtils.isEmpty(fixedWidth.url)) {
    return fixedWidth.url;
  } else if (!TextUtils.isEmpty(model.images.original.url)) {
    return model.images.original.url;
  } else {
    return null;
  }
}
```

使用 `BaseGlideUrlLoader` 允许你跳过构造磁盘缓存键和 `LoadData`，并允许你避免处理委托，只是 `ModelLoader <GlideUrl，InputStream>` 你必须传入构造函数。

#### getHeaders

尽管 Glide 的实例应用都不需要使用 `getHeaders()`，但在拉取非公开图片时需要填入一些授权表单并不罕见。`getHeaders()` 方法可以被选择实现，来为一个给定的模型返回任意合适的 HTTP 头。

例如，如果你有一个字符串授权令牌 (token)，你可以使用 [`LazyHeaders`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/LazyHeaders.html) 类来编写，就像这样：

```
@Nullable
@Override
protected Headers getHeaders(GifResult gifResult, int width, int height, Options options) {
  return new LazyHeaders.Builder()
      .addHeader("Authorization", getAuthToken())
      .build();
}
```

如果你的 `getAuthToken()` 方法特别昂贵，你应该使用 [`LazyHeaderFactory`](https://muyangmin.github.io/glide-docs-cn/javadocs/440/com/bumptech/glide/load/model/LazyHeaderFactory.html) 来代替：

```
@Override
protected Headers getHeaders(GifResult gifResult, int width, int height, Options options) {
  return new LazyHeaders.Builder()
      .addHeader("Authorization", new LazyHeaderFactory() {
        @Nullable
        @Override
        public String buildHeader() {
          return getAuthToken();
        }
      })
      .build();
}
```

使用 `LazyHeaderFactory` 将避免执行昂贵的调用，直到 `DataFetcher` 中发生 HTTP 请求。尽管 `ModelLoader` 方法是在后台线程中被调用， `buildLoadData()` 即使在对应的图片已经被缓存到 Glide 的磁盘缓存时也会被调用。因此，在 `buildLoadData()` 方法或任何 `BaseGlideUrlLoader` 方法中去做昂贵的工作是很浪费的，因为其结果可能根本不会使用到。使用 `LazyHeaderFactory` 将延迟其工作，这将显著节省昂贵的获取 header 的时间。

## 鸣谢 (Credits)

感谢 @jasonch 为 Glide 的 [Data Uri ModelLoader 实现](https://github.com/bumptech/glide/blob/c3dafde00a061bafcd43a739336ca3503af13a7d/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java#L19) 所做的工作。



## 问题测试用例 

原文链接：[点击查看](http://bumptech.github.io/glide/tut/failing-test-cases.html)

- [初始化设置](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#初始化设置)
- 添加一个仪器测试 (Instrumentation test)
  - [添加一个测试文件](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#添加一个测试文件)
  - 编写你的仪器测试
    - [设置](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#设置)
    - [添加一个测试方法](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#添加一个测试方法)
    - 编写一个失败测试
      - [创建测试方法](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#创建测试方法)
      - [获取测试数据](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#获取测试数据)
      - [运行 Glide](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#运行-glide)
      - [断言输出](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#断言输出)
      - [总结](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#总结)
- [执行仪器测试](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#执行仪器测试)
- [创建一个 Pull Request](https://muyangmin.github.io/glide-docs-cn/tut/failing-test-cases.html#创建一个-pull-request)

在为 Glide 报告 bug 的时候，如果您能同时提供一个 Pull Request 包含失败的测试用例 (failing test case) 以演示你正在报告的问题，会对我们很有帮助。失败测试用例可以协助避免交流问题，使维护者容易复现问题，并可在一定程度上提供在将来不再复现该问题的一些保障。

这个指南将手把手地带您撰写一个失败测试用例。

## 初始化设置

在编写任何代码之前，你需要有少许的一些前置条件，但如果您正在定期做与 Android 应用相关的工作，这其中大部分您应该都已经满足：

1. 安装并设置 [Android Studio](https://developer.android.com/studio/index.html)
2. 在 Android Studio 中创建一个 [Android 模拟器](https://developer.android.com/studio/run/managing-avds.html#createavd)，可以使用 x86 和 API 26。
3. Fork 并 Clone Glide 仓库，然后在 Android Studio 中打开（如有问题，请参阅 [贡献代码或文档](http://bumptech.github.io/glide/dev/contributing.html#contribution-workflow)）

## 添加一个仪器测试 (Instrumentation test)

现在你已经在 Android Studio 中打开了 Glide 了，下一步是编写一个仪器测试，它将会因为你将要报告的 bug 而失败。

Glide 的仪器测试存在于项目根目录下一个叫做 `instrumentation` 的 module 中。完整的仪器测试路径为 `glide/instrumentation/src/androidTest/java`。

### 添加一个测试文件

让我们来添加一个新的仪器测试文件：

1. 在 Android Studio 的 Project 窗口中，展开 `instrumentation/src/androidTest/java`
2. 右击 `com.bumptech.glide` （或任何合适的 package ）
3. 高亮 `New` 然后选择 `Java Class`
4. 输入一个合适的名字(如果你有 Issue 编号则可以使用 `Issue###Test`，否则可以使用其他描述问题的名称)
5. 点击 `OK`

你现在应该看到一个新的 Java 类，看起来像这样：

```
package com.bumptech.glide;

public class IssueXyzTest {

}
```

到这里，你已经准备好继续编写你的测试了。

### 编写你的仪器测试

添加了你的测试文件之后，在编写之前，你需要做一些小的设置来让你的测试可以可靠地执行。

#### 设置

首先，你需要为你的测试类添加 `@RunWith(AndroidJUnit4.class)` 来指定 JUnit 4 测试执行器：

```
package com.bumptech.glide;

import android.support.test.runner.AndroidJUnit4;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class IssueXyzTest {

}
```

接下来你需要添加 `TearDownGlide` 规则，它可以确保其他测试的线程或配置不会与你的测试重合。只需要在你的文件顶部添加一行代码：

```
package com.bumptech.glide;

import android.support.test.runner.AndroidJUnit4;
import com.bumptech.glide.test.TearDownGlide;
import org.junit.Rule;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class IssueXyzTest {
  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();

}
```

然后我们将创建一个 Glide 的 `ConcurrencyHelper` 实例来帮助我们确保我们的步骤有序执行：

```
package com.bumptech.glide;

import android.support.test.runner.AndroidJUnit4;
import com.bumptech.glide.test.ConcurrencyHelper;
import com.bumptech.glide.test.TearDownGlide;
import org.junit.Rule;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class IssueXyzTest {
  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();

}
```

最后，我们将添加一个 `@Before` 步骤来创建一个 `Context` 对象，我们将在大部分测试和帮助方法中用到它：

```
package com.bumptech.glide;

import android.support.test.runner.AndroidJUnit4;
import com.bumptech.glide.test.ConcurrencyHelper;
import com.bumptech.glide.test.TearDownGlide;
import org.junit.Rule;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class IssueXyzTest {
  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
  private Context context;

  @Before
  public void setUp() {
    context = InstrumentationRegistry.getTargetContext();
  }
}
```

就是这些！你已经准备好编写你的实际测试了。

#### 添加一个测试方法

接下来是添加你的特定测试方法。在类文件中添加一个方法，它需要被 `@Test` 注解以使 JUnit 知道要执行它：

```
@Test
public void method_withSomeSetup_producesExpectedResult() {
}
```

理想情况下，测试方法命名应该如上例一样填入特定于你的问题的信息，但没有除了 `@Test` 注解之外的强制要求。

#### 编写一个失败测试

因为我们需要编写一些有用的测试用例，我们将使用 [Issue #2638](https://github.com/bumptech/glide/issues/2638) 来作为例子，并编写一个测试以覆盖这里报告的问题。

这个问题似乎是报告者先执行：

```
byte[] data = ...
Glide.with(context)
  .load(data)
  .into(imageView);
```

然后执行:

```
byte[] otherData = ...
Glide.with(context)
  .load(data)
  .into(imageView);
```

即使传给 Glide 的两个 `byte[]` 数组包含的数据并不相同，`ImageView` 中显示的图片也没有改变。

我们可以相当简单地复制这个问题，通过创建两个 `byte[]` 并包含不同的图片，然后将他们依次加载到一个 ImageView 中，然后断言这个 ImageView 上设置的 `Drawable` 是不同的。

##### 创建测试方法

首先让我们创建一个方法，并合理命名：

```
@Test
public void intoImageView_withDifferentByteArrays_loadsDifferentImages() {
  // TODO: fill this in.
}
```

因为我们将需要一个 `ImageView` 来加载图片，所以我们也需要创建它：

```
@Test
public void intoImageView_withDifferentByteArrays_loadsDifferentImages() {
  final ImageView imageView = new ImageView(context);
  imageView.setLayoutParams(new LayoutParams(/*w=*/ 100, /*h=*/ 100));
}
```

##### 获取测试数据

接下来我们将需要我们将要加载的实际数据。 Glide 的仪器测试包含了一个标准的测试图片，我们可以使用它作为第一个图片。我们需要编写一个函数以加载这个图片的字节：

```
private byte[] loadCanonicalBytes() throws IOException {
  int resourceId = ResourceIds.raw.canonical;
  Resources resources = context.getResources();
  InputStream is = resources.openRawResource(resourceId);
  return ByteStreams.toByteArray(is);
}
```

接下来我们需要编写一个函数提供不同的图片的字节。我们可以添加另一个资源到 `instrumentation/src/main/res/raw` 或 `instrumentation/src/main/res/drawable` 并复用我们的上一个方法，但我们也可以通过另一个方法，仅仅修改我们的标准图片的一个像素：

```
private byte[] getModifiedBytes() throws IOException {
  byte[] canonicalBytes = getCanonicalBytes();
  BitmapFactory.Options options = new BitmapFactory.Options();
  options.inMutable = true;
  Bitmap bitmap = 
      BitmapFactory.decodeByteArray(canonicalBytes, 0 ,canonicalBytes.length, options);
  bitmap.setPixel(0, 0, Color.TRANSPARENT);
  ByteArrayOutputStream os = new ByteArrayOutputStream();
  bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
  return os.toByteArray();
}
```

##### 运行 Glide

现在只剩下编写上面的两行加载代码：

```
@Test
public void intoImageView_withDifferentByteArrays_loadsDifferentImages() throws IOException {
  final ImageView imageView = new ImageView(context);
  imageView.setLayoutParams(new LayoutParams(/*w=*/ 100, /*h=*/ 100));

  final byte[] canonicalBytes = getCanonicalBytes();
  final byte[] modifiedBytes = getModifiedBytes();

  concurrency.loadOnMainThread(Glide.with(context).load(canonicalBytes), imageView);
  Bitmap firstBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();

  concurrency.loadOnMainThread(Glide.with(context).load(modifiedBytes), imageView);
  Bitmap secondBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();
}
```

这里我们使用了 `ConcurrencyHelper`，以使 Glide 的加载在主线程执行，并等待它完成。如果我们只是直接使用 `into()`，加载将会异步发生，而在下一行执行之前可能并没有完成，而我们在下一行将试图取回 `ImageView` 里的 `Bitmap`。然后它将抛出一个异常，因为我们最后在一个 `null` `Drawable` 上调用了 `getBitmap`。

最后，我们需要添加我们的断言：两个 Bitmap 实际上包含不同的数据：

##### 断言输出

```
BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
```

`BitmapSubject` 是一个 Glide 里的辅助类，可以帮助你在一起测试中对 `Bitmap` 做比较时做一些基本的断言操作。

##### 总结

我们现在已经编写了一个测试，它会生成一些测试数据，在 Glide 中执行一些方法，获取这些 Glide 方法的输出，并比较输出结果以确保它符合我们的预期。

我们的完整测试来看起来像这样：

```
package com.bumptech.glide;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.drawable.BitmapDrawable;
import android.support.test.InstrumentationRegistry;
import android.support.test.runner.AndroidJUnit4;
import android.widget.AbsListView.LayoutParams;
import android.widget.ImageView;
import com.bumptech.glide.test.BitmapSubject;
import com.bumptech.glide.test.ConcurrencyHelper;
import com.bumptech.glide.test.ResourceIds;
import com.bumptech.glide.test.TearDownGlide;
import com.google.common.io.ByteStreams;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.ExecutionException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class Issue2638Test {
  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();
  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();
  private Context context;

  @Before
  public void setUp() {
    context = InstrumentationRegistry.getTargetContext();
  }

  @Test
  public void intoImageView_withDifferentByteArrays_loadsDifferentImages()
      throws IOException, ExecutionException, InterruptedException {
    final ImageView imageView = new ImageView(context);
    imageView.setLayoutParams(new LayoutParams(/*w=*/ 100, /*h=*/ 100));

    final byte[] canonicalBytes = getCanonicalBytes();
    final byte[] modifiedBytes = getModifiedBytes();

    Glide.with(context)
        .load(canonicalBytes)
        .submit()
        .get();

    concurrency.loadOnMainThread(Glide.with(context).load(canonicalBytes), imageView);
    Bitmap firstBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();

    concurrency.loadOnMainThread(Glide.with(context).load(modifiedBytes), imageView);
    Bitmap secondBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();

    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);
  }

  private byte[] getModifiedBytes() throws IOException {
    byte[] canonicalBytes = getCanonicalBytes();
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inMutable = true;
    Bitmap bitmap =
        BitmapFactory.decodeByteArray(canonicalBytes, 0, canonicalBytes.length, options);
    bitmap.setPixel(0, 0, Color.TRANSPARENT);
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);
    return os.toByteArray();
  }

  private byte[] getCanonicalBytes() throws IOException {
    int resourceId = ResourceIds.raw.canonical;
    Resources resources = context.getResources();
    InputStream is = resources.openRawResource(resourceId);
    return ByteStreams.toByteArray(is);
  }
}
```

现在只需要执行这个测试并看看它是否工作。

## 执行仪器测试

现在你已经有了一个测试用例，你可以通过下面的方法来执行它：

1. 右击测试文件名，可以在 Project 窗口中，也可以在你的编辑器顶部 Tab 上

2. 点击 `Run 'IssueXyzTest'`

3. 如果打开了一个标题为

     

   ```plaintext
   Edit Configuration
   ```

    

   的窗口，则：

   1. 在 `General` Tab 中
   2. 点击 `Target` 然后选择 `Emulator`
   3. 点击 `Run`

4. 如果打开了一个设备列表：

   1. 在 `Available Virtual Devices` 中：
   2. 点击任意模拟器 (推荐 X86 和 API 26)
   3. 点击 `OK`

你将会看到一个模拟器启动，大概等待 30 秒或一分钟左右直到启动完成。

在模拟器启动之后，你将在 Android Studio 编辑器下方的一个窗口看到测试结果，结果可能为 `All Test Passed` 或 `N tests failed` 并伴随一个异常信息。

在你完成仪器测试的遍历之后，你还应该检查代码风格问题或常见 bug ，请执行：

```
./gradlew build
```

**如果你的测试成功了也OK!**

请将成功和失败的测试一并发送 Pull Request 给我们。如果没有其他，则成功的测试可以帮助我们排除一些无法复现你的 bug 的场景，因此我们的精力可以更集中在其他一些可以复现的场景上。我们也可能会建议做出调整或其他可能导致测试失败的变种，并最终找出问题所在。

## 创建一个 Pull Request

现在你已经编写好了你的测试用例，你需要上传到你的 Glide fork 中并发送一个 Pull Request。

首先你需要提交你的新测试文件：

```
git add intrumentation/src/androidTest/java/com/bumptech/glide/IssueXyzTest.java
git commit -m "Adding test case for issue XYZ"
```

如果你有多个文件需要添加，你可以使用 `git add .`，但请特别小心，因为这么做可能会导致你意外添加一些不需要的文件到提交中。

接下来，推送你的修改到你 GitHub 上的 Glide fork 仓库中：

```
git push origin master
```

然后创建一个 Pull Request：

1. 在你的 GitHub 上打开你的 fork 仓库 (`https://github.com/<your_username>/glide`)
2. 点击 `New pull request` 按钮
3. 继续点击绿色的大大的 `Create pull request` 按钮
4. 添加一个标题 (`Tests for IssueXyz`)
5. 尽可能地填充模板信息
6. 点击 `Create Pull Request`

大功告成！你的 Pull Request 将会被发送，而我们将尽快查看。